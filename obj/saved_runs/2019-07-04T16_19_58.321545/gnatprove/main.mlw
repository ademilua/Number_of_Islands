(* Module for defining the constant "default_priority" defined at system.ads:112, created in Gnat2Why.Decls.Translate_Constant *)
module System__default_priority
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant default_priority [#"system.ads" 112 0 0][@model_trace:7526] [@name:Default_Priority] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the value of constant "default_priority" defined at system.ads:112, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__default_priority___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        System__default_priority as System__default_priority

 axiom default_priority__def_axiom :
  ((System__default_priority.default_priority ) = (48 : int))

end

(* Module for defining the constant "n" defined at main.adb:5, created in Gnat2Why.Decls.Translate_Constant *)
module Main__n
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant n [#"main.adb" 5 0 0][@model_trace:2317] [@name:N] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the value of constant "n" defined at main.adb:5, created in Gnat2Why.Decls.Translate_Constant_Value *)
module Main__n___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Main__n as Main__n

 axiom n__def_axiom :
  ((Main__n.n ) = (4 : int))

end

(* Module for defining the constant "m" defined at main.adb:6, created in Gnat2Why.Decls.Translate_Constant *)
module Main__m
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant m [#"main.adb" 6 0 0][@model_trace:2327] [@name:M] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the value of constant "m" defined at main.adb:6, created in Gnat2Why.Decls.Translate_Constant_Value *)
module Main__m___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Main__m as Main__m

 axiom m__def_axiom :
  ((Main__m.m ) = (5 : int))

end

(* Module for axiomatizing type "int_needed" defined at main.adb:10, created in Gnat2Why.Types.Translate_Type *)
module Main__int_needed
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type int_needed =
  < range 0 1 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (1 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = int_needed, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type int_needed__ref =
  { mutable int_needed__content : int_needed }
 
 function int_needed__ref_int_needed__content__projection 
   (a : int_needed__ref) : int_needed =
  a.int_needed__content
 
 meta "model_projection" function int_needed__ref_int_needed__content__projection
 
 meta "inline:no" function int_needed__ref_int_needed__content__projection
 
 val int_needed__havoc 
   (x : int_needed__ref) : unit
  writes {x}

end

(* Module giving axioms for type "int_needed" defined at main.adb:10, created in Gnat2Why.Types.Generate_Type_Completion *)
module Main__int_needed___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Main__int_needed as Main__int_needed

 predicate dynamic_invariant [@inline] 
   (temp___expr_231 : int) (temp___is_init_227 : bool) (temp___skip_constant_228 : bool) (temp___do_toplevel_229 : bool) (temp___do_typ_inv_230 : bool) =
  (if (( temp___is_init_227 \/ (Main__int_needed.first <= Main__int_needed.last) )) then (
   (Main__int_needed.dynamic_property Main__int_needed.first Main__int_needed.last temp___expr_231)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_231 : int) (temp___is_init_227 : bool) (temp___skip_constant_228 : bool) (temp___do_toplevel_229 : bool) (temp___do_typ_inv_230 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_231 : int) (temp___is_init_227 : bool) (temp___skip_constant_228 : bool) (temp___do_toplevel_229 : bool) (temp___do_typ_inv_230 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_232 : int) (temp___skip_top_level_233 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_232 : int) (temp___skip_top_level_233 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_232 : int) (temp___skip_top_level_233 : bool) }

end

(* Module defining to_rep/of_rep for type "int_needed" defined at main.adb:10, created in Gnat2Why.Types.Translate_Type *)
module Main__int_needed__rep
 use        Main__int_needed as Main__int_needed
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Main__int_needed.int_needed) : int =
  (Main__int_needed.int_needed'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Main__int_needed.int_needed, 
 predicate in_range = Main__int_needed.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing the array theory associated to type "TmapB" defined at main.adb:12, created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int_Int__Main__int_needed
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Main__int_needed as Main__int_needed
 use        Main__int_needed__rep as Main__int_needed__rep

 function index_I1_one 
   : int =
  (1 : int)
 
 function index_I2_one 
   : int =
  (1 : int)
 
 type component_type =
  Main__int_needed.int_needed
 
 clone export "_gnatprove_standard".Array__2 with axiom .,
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type I2.t = int, 
 predicate I2.le = Int.(<=), 
 predicate I2.lt = Int.(<), 
 predicate I2.gt = Int.(>), 
 function I2.add = Int.(+), 
 function I2.sub = Int.(-), 
 function I2.one = index_I2_one, 
 type component_type = component_type
 
 function bool_eq 
   (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) : bool =
  ( ( (if ((a__first <= a__last)) then (
   ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
   (b__first > b__last))) /\ (if ((a__first_2 <= a__last_2)) then (
   ( (b__first_2 <= b__last_2) /\ ((a__last_2 - a__first_2) = (b__last_2 - b__first_2)) )) else (
   (b__first_2 > b__last_2))) ) /\ (forall temp___idx_156   temp___idx_157   : int.
   (if (( ( (a__first <= temp___idx_156) /\ (temp___idx_156 <= a__last) ) /\ ( (a__first_2 <= temp___idx_157) /\ (temp___idx_157 <= a__last_2) ) )) then (
    ((Main__int_needed__rep.to_rep (get a temp___idx_156 temp___idx_157)) = (Main__int_needed__rep.to_rep (get b ((b__first - a__first) + temp___idx_156) ((b__first_2 - a__first_2) + temp___idx_157))))) else true)) )
 val bool_eq 
   (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) : bool
  ensures { result = bool_eq (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) }
 
 axiom bool_eq_rev :
  (forall a   b   : map.
  (forall a__first   a__last   a__first_2   a__last_2   b__first   b__last   b__first_2   b__last_2   : int.
   ( ((bool_eq b b__first b__last b__first_2 b__last_2 a a__first a__last a__first_2 a__last_2) = True) -> ( ( (if ((a__first <= a__last)) then (
    ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
    (b__first > b__last))) /\ (if ((a__first_2 <= a__last_2)) then (
    ( (b__first_2 <= b__last_2) /\ ((a__last_2 - a__first_2) = (b__last_2 - b__first_2)) )) else (
    (b__first_2 > b__last_2))) ) /\ (forall temp___idx_156   temp___idx_157   : int.
    (if (( ( (a__first <= temp___idx_156) /\ (temp___idx_156 <= a__last) ) /\ ( (a__first_2 <= temp___idx_157) /\ (temp___idx_157 <= a__last_2) ) )) then (
     ((Main__int_needed__rep.to_rep (get a temp___idx_156 temp___idx_157)) = (Main__int_needed__rep.to_rep (get b ((b__first - a__first) + temp___idx_156) ((b__first_2 - a__first_2) + temp___idx_157))))) else true)) ) )))

end

(* Module for declaring an abstract function for the aggregate at main.adb:58, created in Gnat2Why.Expr.Transform_Aggregate.Generate_Logic_Function *)
module Main__map_array__aggregate_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed

 val function main__map_array__aggregate_def 
   (temp___163 : int) (temp___164 : int) (temp___165 : int) (temp___166 : int) (temp___167 : int) (temp___168 : int) (temp___169 : int) (temp___170 : int) (temp___171 : int) (temp___172 : int) (temp___173 : int) (temp___174 : int) (temp___175 : int) (temp___176 : int) (temp___177 : int) (temp___178 : int) (temp___179 : int) (temp___180 : int) (temp___181 : int) (temp___182 : int) : Array__Int_Int__Main__int_needed.map

end

(* Module for defining the value of the aggregate at main.adb:58, created in Gnat2Why.Expr.Transform_Aggregate.Generate_Logic_Function *)
module Main__map_array__aggregate_def___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Main__int_needed as Main__int_needed
 use        Main__int_needed___axiom as Main__int_needed___axiom
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Main__map_array__aggregate_def as Main__map_array__aggregate_def
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed

 axiom def_axiom :
  (forall temp___163   temp___164   temp___165   temp___166   temp___167   temp___168   temp___169   temp___170   temp___171   temp___172   temp___173   temp___174   temp___175   temp___176   temp___177   temp___178   temp___179   temp___180   temp___181   temp___182   : int.
   (let temp___162 [@mlw:proxy_symbol] [@introduced]  = (Main__map_array__aggregate_def.main__map_array__aggregate_def temp___163 temp___164 temp___165 temp___166 temp___167 temp___168 temp___169 temp___170 temp___171 temp___172 temp___173 temp___174 temp___175 temp___176 temp___177 temp___178 temp___179 temp___180 temp___181 temp___182) in (
    (if (( ( (Main__int_needed___axiom.dynamic_invariant temp___163 True True True True) /\ (Main__int_needed___axiom.dynamic_invariant temp___164 True True True True) )/\( ( ( ( ( (Main__int_needed___axiom.dynamic_invariant temp___165 True True True True)/\(Main__int_needed___axiom.dynamic_invariant temp___166 True True True True) )/\(Main__int_needed___axiom.dynamic_invariant temp___167 True True True True) )/\( (Main__int_needed___axiom.dynamic_invariant temp___168 True True True True)/\(Main__int_needed___axiom.dynamic_invariant temp___169 True True True True) ) )/\( ( (Main__int_needed___axiom.dynamic_invariant temp___170 True True True True)/\(Main__int_needed___axiom.dynamic_invariant temp___171 True True True True) )/\( (Main__int_needed___axiom.dynamic_invariant temp___172 True True True True)/\(Main__int_needed___axiom.dynamic_invariant temp___173 True True True True) ) ) )/\( ( ( ( (Main__int_needed___axiom.dynamic_invariant temp___174 True True True True)/\(Main__int_needed___axiom.dynamic_invariant temp___175 True True True True) )/\(Main__int_needed___axiom.dynamic_invariant temp___176 True True True True) )/\( (Main__int_needed___axiom.dynamic_invariant temp___177 True True True True)/\(Main__int_needed___axiom.dynamic_invariant temp___178 True True True True) ) )/\( ( (Main__int_needed___axiom.dynamic_invariant temp___179 True True True True)/\(Main__int_needed___axiom.dynamic_invariant temp___180 True True True True) )/\( (Main__int_needed___axiom.dynamic_invariant temp___181 True True True True)/\(Main__int_needed___axiom.dynamic_invariant temp___182 True True True True) ) ) ) ) )) then (
     ( ( ( ( ((Array__Int_Int__Main__int_needed.get temp___162 (1 : int) (1 : int)) = ( 1 : Main__int_needed.int_needed )) /\ ((Array__Int_Int__Main__int_needed.get temp___162 (1 : int) (2 : int)) = ( 0 : Main__int_needed.int_needed )) )/\( ( ((Array__Int_Int__Main__int_needed.get temp___162 (1 : int) (3 : int)) = ( 1 : Main__int_needed.int_needed ))/\((Array__Int_Int__Main__int_needed.get temp___162 (1 : int) (4 : int)) = ( 1 : Main__int_needed.int_needed )) )/\((Array__Int_Int__Main__int_needed.get temp___162 (1 : int) (5 : int)) = ( 0 : Main__int_needed.int_needed )) ) ) /\ ( ( ((Array__Int_Int__Main__int_needed.get temp___162 (2 : int) (1 : int)) = ( 1 : Main__int_needed.int_needed )) /\ ((Array__Int_Int__Main__int_needed.get temp___162 (2 : int) (2 : int)) = ( 0 : Main__int_needed.int_needed )) )/\( ( ((Array__Int_Int__Main__int_needed.get temp___162 (2 : int) (3 : int)) = ( 0 : Main__int_needed.int_needed ))/\((Array__Int_Int__Main__int_needed.get temp___162 (2 : int) (4 : int)) = ( 1 : Main__int_needed.int_needed )) )/\((Array__Int_Int__Main__int_needed.get temp___162 (2 : int) (5 : int)) = ( 0 : Main__int_needed.int_needed )) ) ) )/\( ( ( ((Array__Int_Int__Main__int_needed.get temp___162 (3 : int) (1 : int)) = ( 1 : Main__int_needed.int_needed )) /\ ((Array__Int_Int__Main__int_needed.get temp___162 (3 : int) (2 : int)) = ( 1 : Main__int_needed.int_needed )) )/\( ( ((Array__Int_Int__Main__int_needed.get temp___162 (3 : int) (3 : int)) = ( 0 : Main__int_needed.int_needed ))/\((Array__Int_Int__Main__int_needed.get temp___162 (3 : int) (4 : int)) = ( 1 : Main__int_needed.int_needed )) )/\((Array__Int_Int__Main__int_needed.get temp___162 (3 : int) (5 : int)) = ( 0 : Main__int_needed.int_needed )) ) )/\( ( ((Array__Int_Int__Main__int_needed.get temp___162 (4 : int) (1 : int)) = ( 0 : Main__int_needed.int_needed )) /\ ((Array__Int_Int__Main__int_needed.get temp___162 (4 : int) (2 : int)) = ( 0 : Main__int_needed.int_needed )) )/\( ( ((Array__Int_Int__Main__int_needed.get temp___162 (4 : int) (3 : int)) = ( 1 : Main__int_needed.int_needed ))/\((Array__Int_Int__Main__int_needed.get temp___162 (4 : int) (4 : int)) = ( 0 : Main__int_needed.int_needed )) )/\((Array__Int_Int__Main__int_needed.get temp___162 (4 : int) (5 : int)) = ( 0 : Main__int_needed.int_needed )) ) ) ) )) else true)))
  )

end

(* Module for defining the constant "map_array" defined at main.adb:58, created in Gnat2Why.Decls.Translate_Constant *)
module Main__map_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed

 val constant map_array [#"main.adb" 58 0 0][@model_projected] [@name:Map_Array] [@model_trace:2665] 
   : Array__Int_Int__Main__int_needed.map

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the value of constant "map_array" defined at main.adb:58, created in Gnat2Why.Decls.Translate_Constant_Value *)
module Main__map_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Main__map_array as Main__map_array
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Main__map_array__aggregate_def as Main__map_array__aggregate_def
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed

 axiom map_array__def_axiom :
  ((Main__map_array.map_array ) = (Main__map_array__aggregate_def.main__map_array__aggregate_def (1 : int) (0 : int) (1 : int) (1 : int) (0 : int) (1 : int) (0 : int) (0 : int) (1 : int) (0 : int) (1 : int) (1 : int) (0 : int) (1 : int) (0 : int) (0 : int) (0 : int) (1 : int) (0 : int) (0 : int)))

end

(* Module for possibly declaring a logic function for "line_length__2" defined at a-textio.ads:245, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada___ada__text_io__line_length__2
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main

 val function line_length__2 
   (ada___ada__text_io__standard_in : Main.__private) (ada___ada__text_io__file_system : Main.__private) (ada___ada__text_io__standard_out : Main.__private) (ada___ada__text_io__standard_err : Main.__private) (ada___ada__text_io__current_in : Main.__private) (ada___ada__text_io__current_out : Main.__private) (ada___ada__text_io__current_err : Main.__private) : int
 
 val predicate line_length__2__function_guard 
   (temp___result_154 : int) (ada___ada__text_io__standard_in : Main.__private) (ada___ada__text_io__file_system : Main.__private) (ada___ada__text_io__standard_out : Main.__private) (ada___ada__text_io__standard_err : Main.__private) (ada___ada__text_io__current_in : Main.__private) (ada___ada__text_io__current_out : Main.__private) (ada___ada__text_io__current_err : Main.__private)

end

(* Module for axiomatizing type "count" defined at a-textio.ads:77, created in Gnat2Why.Types.Translate_Type *)
module Ada___ada__text_io__count
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type count =
  < range 0 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = count, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type count__ref =
  { mutable count__content : count }
 
 function count__ref_count__content__projection 
   (a : count__ref) : count =
  a.count__content
 
 meta "model_projection" function count__ref_count__content__projection
 
 meta "inline:no" function count__ref_count__content__projection
 
 val count__havoc 
   (x : count__ref) : unit
  writes {x}

end

(* Module giving axioms for type "count" defined at a-textio.ads:77, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada___ada__text_io__count___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Ada___ada__text_io__count as Ada___ada__text_io__count

 predicate dynamic_invariant [@inline] 
   (temp___expr_189 : int) (temp___is_init_185 : bool) (temp___skip_constant_186 : bool) (temp___do_toplevel_187 : bool) (temp___do_typ_inv_188 : bool) =
  (if (( temp___is_init_185 \/ (Ada___ada__text_io__count.first <= Ada___ada__text_io__count.last) )) then (
   (Ada___ada__text_io__count.dynamic_property Ada___ada__text_io__count.first Ada___ada__text_io__count.last temp___expr_189)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_189 : int) (temp___is_init_185 : bool) (temp___skip_constant_186 : bool) (temp___do_toplevel_187 : bool) (temp___do_typ_inv_188 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_189 : int) (temp___is_init_185 : bool) (temp___skip_constant_186 : bool) (temp___do_toplevel_187 : bool) (temp___do_typ_inv_188 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_190 : int) (temp___skip_top_level_191 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_190 : int) (temp___skip_top_level_191 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_190 : int) (temp___skip_top_level_191 : bool) }

end

(* Module declaring the external object "ada___ada__text_io__standard_in," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada___ada__text_io__standard_in
 use        "_gnatprove_standard".Main
 use        "int".Int

 val standard_in  : Main.__private__ref 

end

(* Module declaring the external object "ada___ada__text_io__file_system," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada___ada__text_io__file_system
 use        "_gnatprove_standard".Main
 use        "int".Int

 val file_system  : Main.__private__ref 

end

(* Module declaring the external object "ada___ada__text_io__standard_out," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada___ada__text_io__standard_out
 use        "_gnatprove_standard".Main
 use        "int".Int

 val standard_out  : Main.__private__ref 

end

(* Module declaring the external object "ada___ada__text_io__standard_err," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada___ada__text_io__standard_err
 use        "_gnatprove_standard".Main
 use        "int".Int

 val standard_err  : Main.__private__ref 

end

(* Module declaring the external object "ada___ada__text_io__current_in," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada___ada__text_io__current_in
 use        "_gnatprove_standard".Main
 use        "int".Int

 val current_in  : Main.__private__ref 

end

(* Module declaring the external object "ada___ada__text_io__current_out," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada___ada__text_io__current_out
 use        "_gnatprove_standard".Main
 use        "int".Int

 val current_out  : Main.__private__ref 

end

(* Module declaring the external object "ada___ada__text_io__current_err," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada___ada__text_io__current_err
 use        "_gnatprove_standard".Main
 use        "int".Int

 val current_err  : Main.__private__ref 

end

(* Module for declaring a program function (and possibly an axiom) for "line_length__2" defined at a-textio.ads:245, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada___ada__text_io__line_length__2___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        Ada___ada__text_io__line_length__2 as Ada___ada__text_io__line_length__2
 use        Ada___ada__text_io__count___axiom as Ada___ada__text_io__count___axiom
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err

 val line_length__2 
   (__void_param : unit) : int
  requires {  true }
  ensures {  ( ( (result = (Ada___ada__text_io__line_length__2.line_length__2 Ada___ada__text_io__standard_in.standard_in.Main.__private__content Ada___ada__text_io__file_system.file_system.Main.__private__content Ada___ada__text_io__standard_out.standard_out.Main.__private__content Ada___ada__text_io__standard_err.standard_err.Main.__private__content Ada___ada__text_io__current_in.current_in.Main.__private__content Ada___ada__text_io__current_out.current_out.Main.__private__content Ada___ada__text_io__current_err.current_err.Main.__private__content)) /\ true )/\(Ada___ada__text_io__count___axiom.dynamic_invariant result True False True True) ) }
  reads {Ada___ada__text_io__standard_in.standard_in, Ada___ada__text_io__file_system.file_system, Ada___ada__text_io__standard_out.standard_out, Ada___ada__text_io__standard_err.standard_err, Ada___ada__text_io__current_in.current_in, Ada___ada__text_io__current_out.current_out, Ada___ada__text_io__current_err.current_err}
 
 axiom line_length__2__post_axiom :
  (forall ada___ada__text_io__standard_in   ada___ada__text_io__file_system   ada___ada__text_io__standard_out   ada___ada__text_io__standard_err   ada___ada__text_io__current_in   ada___ada__text_io__current_out   ada___ada__text_io__current_err   : Main.__private [(Ada___ada__text_io__line_length__2.line_length__2 ada___ada__text_io__standard_in ada___ada__text_io__file_system ada___ada__text_io__standard_out ada___ada__text_io__standard_err ada___ada__text_io__current_in ada___ada__text_io__current_out ada___ada__text_io__current_err)].
   ( true -> (let result  = (Ada___ada__text_io__line_length__2.line_length__2 ada___ada__text_io__standard_in ada___ada__text_io__file_system ada___ada__text_io__standard_out ada___ada__text_io__standard_err ada___ada__text_io__current_in ada___ada__text_io__current_out ada___ada__text_io__current_err) in (
    ( ( true /\ (Ada___ada__text_io__count___axiom.dynamic_invariant result True False True True) )/\true )))
    ))

end

(* Module for possibly declaring a logic function for "page_length__2" defined at a-textio.ads:251, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada___ada__text_io__page_length__2
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main

 val function page_length__2 
   (ada___ada__text_io__standard_in : Main.__private) (ada___ada__text_io__file_system : Main.__private) (ada___ada__text_io__standard_out : Main.__private) (ada___ada__text_io__standard_err : Main.__private) (ada___ada__text_io__current_in : Main.__private) (ada___ada__text_io__current_out : Main.__private) (ada___ada__text_io__current_err : Main.__private) : int
 
 val predicate page_length__2__function_guard 
   (temp___result_155 : int) (ada___ada__text_io__standard_in : Main.__private) (ada___ada__text_io__file_system : Main.__private) (ada___ada__text_io__standard_out : Main.__private) (ada___ada__text_io__standard_err : Main.__private) (ada___ada__text_io__current_in : Main.__private) (ada___ada__text_io__current_out : Main.__private) (ada___ada__text_io__current_err : Main.__private)

end

(* Module for declaring a program function (and possibly an axiom) for "page_length__2" defined at a-textio.ads:251, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada___ada__text_io__page_length__2___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        Ada___ada__text_io__page_length__2 as Ada___ada__text_io__page_length__2
 use        Ada___ada__text_io__count___axiom as Ada___ada__text_io__count___axiom
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err

 val page_length__2 
   (__void_param : unit) : int
  requires {  true }
  ensures {  ( ( (result = (Ada___ada__text_io__page_length__2.page_length__2 Ada___ada__text_io__standard_in.standard_in.Main.__private__content Ada___ada__text_io__file_system.file_system.Main.__private__content Ada___ada__text_io__standard_out.standard_out.Main.__private__content Ada___ada__text_io__standard_err.standard_err.Main.__private__content Ada___ada__text_io__current_in.current_in.Main.__private__content Ada___ada__text_io__current_out.current_out.Main.__private__content Ada___ada__text_io__current_err.current_err.Main.__private__content)) /\ true )/\(Ada___ada__text_io__count___axiom.dynamic_invariant result True False True True) ) }
  reads {Ada___ada__text_io__standard_in.standard_in, Ada___ada__text_io__file_system.file_system, Ada___ada__text_io__standard_out.standard_out, Ada___ada__text_io__standard_err.standard_err, Ada___ada__text_io__current_in.current_in, Ada___ada__text_io__current_out.current_out, Ada___ada__text_io__current_err.current_err}
 
 axiom page_length__2__post_axiom :
  (forall ada___ada__text_io__standard_in   ada___ada__text_io__file_system   ada___ada__text_io__standard_out   ada___ada__text_io__standard_err   ada___ada__text_io__current_in   ada___ada__text_io__current_out   ada___ada__text_io__current_err   : Main.__private [(Ada___ada__text_io__page_length__2.page_length__2 ada___ada__text_io__standard_in ada___ada__text_io__file_system ada___ada__text_io__standard_out ada___ada__text_io__standard_err ada___ada__text_io__current_in ada___ada__text_io__current_out ada___ada__text_io__current_err)].
   ( true -> (let result  = (Ada___ada__text_io__page_length__2.page_length__2 ada___ada__text_io__standard_in ada___ada__text_io__file_system ada___ada__text_io__standard_out ada___ada__text_io__standard_err ada___ada__text_io__current_in ada___ada__text_io__current_out ada___ada__text_io__current_err) in (
    ( ( true /\ (Ada___ada__text_io__count___axiom.dynamic_invariant result True False True True) )/\true )))
    ))

end

(* Module for declaring a program function (and possibly an axiom) for "main" defined at main.adb:2, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Main___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err

 val main 
   (__void_param : unit) : unit
  requires {  true }
  ensures {  true }
  reads {Ada___ada__text_io__standard_in.standard_in, Ada___ada__text_io__file_system.file_system, Ada___ada__text_io__standard_out.standard_out, Ada___ada__text_io__standard_err.standard_err, Ada___ada__text_io__current_in.current_in, Ada___ada__text_io__current_out.current_out, Ada___ada__text_io__current_err.current_err}
  writes {Ada___ada__text_io__standard_in.standard_in, Ada___ada__text_io__file_system.file_system, Ada___ada__text_io__standard_out.standard_out, Ada___ada__text_io__standard_err.standard_err, Ada___ada__text_io__current_in.current_in, Ada___ada__text_io__current_out.current_out, Ada___ada__text_io__current_err.current_err}

end

(* Module for axiomatizing the array theory associated to type "TvisitedB" defined at main.adb:14, created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int_Int__Bool
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 function index_I1_one 
   : int =
  (1 : int)
 
 function index_I2_one 
   : int =
  (1 : int)
 
 type component_type =
  bool
 
 clone export "_gnatprove_standard".Array__2 with axiom .,
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type I2.t = int, 
 predicate I2.le = Int.(<=), 
 predicate I2.lt = Int.(<), 
 predicate I2.gt = Int.(>), 
 function I2.add = Int.(+), 
 function I2.sub = Int.(-), 
 function I2.one = index_I2_one, 
 type component_type = component_type
 
 function bool_eq 
   (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) : bool =
  ( ( (if ((a__first <= a__last)) then (
   ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
   (b__first > b__last))) /\ (if ((a__first_2 <= a__last_2)) then (
   ( (b__first_2 <= b__last_2) /\ ((a__last_2 - a__first_2) = (b__last_2 - b__first_2)) )) else (
   (b__first_2 > b__last_2))) ) /\ (forall temp___idx_158   temp___idx_159   : int.
   (if (( ( (a__first <= temp___idx_158) /\ (temp___idx_158 <= a__last) ) /\ ( (a__first_2 <= temp___idx_159) /\ (temp___idx_159 <= a__last_2) ) )) then (
    ((get a temp___idx_158 temp___idx_159) = (get b ((b__first - a__first) + temp___idx_158) ((b__first_2 - a__first_2) + temp___idx_159)))) else true)) )
 val bool_eq 
   (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) : bool
  ensures { result = bool_eq (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) }
 
 axiom bool_eq_rev :
  (forall a   b   : map.
  (forall a__first   a__last   a__first_2   a__last_2   b__first   b__last   b__first_2   b__last_2   : int.
   ( ((bool_eq b b__first b__last b__first_2 b__last_2 a a__first a__last a__first_2 a__last_2) = True) -> ( ( (if ((a__first <= a__last)) then (
    ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
    (b__first > b__last))) /\ (if ((a__first_2 <= a__last_2)) then (
    ( (b__first_2 <= b__last_2) /\ ((a__last_2 - a__first_2) = (b__last_2 - b__first_2)) )) else (
    (b__first_2 > b__last_2))) ) /\ (forall temp___idx_158   temp___idx_159   : int.
    (if (( ( (a__first <= temp___idx_158) /\ (temp___idx_158 <= a__last) ) /\ ( (a__first_2 <= temp___idx_159) /\ (temp___idx_159 <= a__last_2) ) )) then (
     ((get a temp___idx_158 temp___idx_159) = (get b ((b__first - a__first) + temp___idx_158) ((b__first_2 - a__first_2) + temp___idx_159)))) else true)) ) )))

end

(* Module for possibly declaring a logic function for "visit_islands" defined at main.adb:16, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Main__visit_islands
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val function visit_islands 
   (map_array : Array__Int_Int__Main__int_needed.map) (i : int) (j : int) (visited_array : Array__Int_Int__Bool.map) : Array__Int_Int__Bool.map
 
 val predicate visit_islands__function_guard 
   (temp___result_160 : Array__Int_Int__Bool.map) (map_array : Array__Int_Int__Main__int_needed.map) (i : int) (j : int) (visited_array : Array__Int_Int__Bool.map)

end

(* Module giving axioms for type "visited" defined at main.adb:14, created in Gnat2Why.Types.Generate_Type_Completion *)
module Main__visited___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 predicate dynamic_invariant [@inline] 
   (temp___expr_250 : Array__Int_Int__Bool.map) (temp___is_init_246 : bool) (temp___skip_constant_247 : bool) (temp___do_toplevel_248 : bool) (temp___do_typ_inv_249 : bool) =
  true
 val dynamic_invariant [@inline] 
   (temp___expr_250 : Array__Int_Int__Bool.map) (temp___is_init_246 : bool) (temp___skip_constant_247 : bool) (temp___do_toplevel_248 : bool) (temp___do_typ_inv_249 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_250 : Array__Int_Int__Bool.map) (temp___is_init_246 : bool) (temp___skip_constant_247 : bool) (temp___do_toplevel_248 : bool) (temp___do_typ_inv_249 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_253 : Array__Int_Int__Bool.map) (temp___skip_top_level_254 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_253 : Array__Int_Int__Bool.map) (temp___skip_top_level_254 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_253 : Array__Int_Int__Bool.map) (temp___skip_top_level_254 : bool) }

end

(* Module for declaring a program function (and possibly an axiom) for "visit_islands" defined at main.adb:16, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Main__visit_islands___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Main__visit_islands as Main__visit_islands
 use        Main__visited___axiom as Main__visited___axiom
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val visit_islands 
   (map_array : Array__Int_Int__Main__int_needed.map) (i : int) (j : int) (visited_array : Array__Int_Int__Bool.map) : Array__Int_Int__Bool.map
  requires {  true }
  ensures {  ( ( (result = (Main__visit_islands.visit_islands map_array i j visited_array)) /\ (Main__visit_islands.visit_islands__function_guard result map_array i j visited_array) )/\(Main__visited___axiom.dynamic_invariant result True False True True) ) }

end

(* Module for axiomatizing type "integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type integer =
  < range -2147483648 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (( -2147483648) : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type integer__ref =
  { mutable integer__content : integer }
 
 function integer__ref_integer__content__projection 
   (a : integer__ref) : integer =
  a.integer__content
 
 meta "model_projection" function integer__ref_integer__content__projection
 
 meta "inline:no" function integer__ref_integer__content__projection
 
 val integer__havoc 
   (x : integer__ref) : unit
  writes {x}

end

(* Module giving axioms for type "integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer as Standard__integer

 predicate dynamic_invariant [@inline] 
   (temp___expr_18 : int) (temp___is_init_14 : bool) (temp___skip_constant_15 : bool) (temp___do_toplevel_16 : bool) (temp___do_typ_inv_17 : bool) =
  (if (( temp___is_init_14 \/ (Standard__integer.first <= Standard__integer.last) )) then (
   (Standard__integer.dynamic_property Standard__integer.first Standard__integer.last temp___expr_18)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_18 : int) (temp___is_init_14 : bool) (temp___skip_constant_15 : bool) (temp___do_toplevel_16 : bool) (temp___do_typ_inv_17 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_18 : int) (temp___is_init_14 : bool) (temp___skip_constant_15 : bool) (temp___do_toplevel_16 : bool) (temp___do_typ_inv_17 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_19 : int) (temp___skip_top_level_20 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_19 : int) (temp___skip_top_level_20 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_19 : int) (temp___skip_top_level_20 : bool) }

end

(* Module for possibly declaring a logic function for "count_islands" defined at main.adb:38, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Main__count_islands
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed

 val function count_islands 
   (map_array : Array__Int_Int__Main__int_needed.map) : int
 
 val predicate count_islands__function_guard 
   (temp___result_161 : int) (map_array : Array__Int_Int__Main__int_needed.map)

end

(* Module for declaring a program function (and possibly an axiom) for "count_islands" defined at main.adb:38, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Main__count_islands___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Standard__integer as Standard__integer
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Main__count_islands as Main__count_islands
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed

 val count_islands 
   (map_array : Array__Int_Int__Main__int_needed.map) : int
  requires {  true }
  ensures {  ( ( (result = (Main__count_islands.count_islands map_array)) /\ (Main__count_islands.count_islands__function_guard result map_array) )/\(Standard__integer___axiom.dynamic_invariant result True False True True) ) }
 
 axiom count_islands__post_axiom :
  (forall map_array   : Array__Int_Int__Main__int_needed.map [(Main__count_islands.count_islands map_array)].
   (let result  = (Main__count_islands.count_islands map_array) in (
    (Standard__integer.dynamic_property Standard__integer.first Standard__integer.last result)))
  )

end

(* Module for axiomatizing type "positive", created in Gnat2Why.Types.Translate_Type *)
module Standard__positive
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type positive =
  < range 1 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (1 : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = positive, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type positive__ref =
  { mutable positive__content : positive }
 
 function positive__ref_positive__content__projection 
   (a : positive__ref) : positive =
  a.positive__content
 
 meta "model_projection" function positive__ref_positive__content__projection
 
 meta "inline:no" function positive__ref_positive__content__projection
 
 val positive__havoc 
   (x : positive__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "character", created in Gnat2Why.Types.Translate_Type *)
module Standard__character
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type character 
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (255 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = character, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type character__ref =
  { mutable character__content : character }
 
 function character__ref_character__content__projection 
   (a : character__ref) : character =
  a.character__content
 
 meta "model_projection" function character__ref_character__content__projection
 
 meta "inline:no" function character__ref_character__content__projection
 
 val character__havoc 
   (x : character__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "character", created in Gnat2Why.Types.Translate_Type *)
module Standard__character__rep
 use        Standard__character as Standard__character
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__character.character, 
 predicate in_range = Standard__character.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing the array theory associated to type "string", created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Standard__character
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__character as Standard__character
 use        Standard__character__rep as Standard__character__rep

 function index_I1_one 
   : int =
  (1 : int)
 
 type component_type =
  Standard__character.character
 
 clone export "_gnatprove_standard".Array__1 with axiom .,
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool =
  ( (if ((a__first <= a__last)) then (
   ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
   (b__first > b__last))) /\ (forall temp___idx_91   : int.
   (if (( (a__first <= temp___idx_91) /\ (temp___idx_91 <= a__last) )) then (
    ((Standard__character__rep.to_rep (get a temp___idx_91)) = (Standard__character__rep.to_rep (get b ((b__first - a__first) + temp___idx_91))))) else true)) )
 val bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool
  ensures { result = bool_eq (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) }
 
 axiom bool_eq_rev :
  (forall a   b   : map.
  (forall a__first   a__last   b__first   b__last   : int.
   ( ((bool_eq b b__first b__last a a__first a__last) = True) -> ( (if ((a__first <= a__last)) then (
    ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
    (b__first > b__last))) /\ (forall temp___idx_91   : int.
    (if (( (a__first <= temp___idx_91) /\ (temp___idx_91 <= a__last) )) then (
     ((Standard__character__rep.to_rep (get a temp___idx_91)) = (Standard__character__rep.to_rep (get b ((b__first - a__first) + temp___idx_91))))) else true)) ) )))

end

(* Module defining to_rep/of_rep for type "integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer__rep
 use        Standard__integer as Standard__integer
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__integer.integer) : int =
  (Standard__integer.integer'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__integer.integer, 
 predicate in_range = Standard__integer.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "string", created in Gnat2Why.Types.Translate_Type *)
module Standard__string
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer as Standard__integer
 use        Standard__positive as Standard__positive
 use        Standard__character as Standard__character
 use        Array__Int__Standard__character as Array__Int__Standard__character
 use        Standard__integer__rep as Standard__integer__rep

 type component_type =
  Standard__character.character
 
 function index_1_id 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with axiom .,
 type map = Array__Int__Standard__character.map, 
 function array_bool_eq = Array__Int__Standard__character.bool_eq, 
 type index_base_type = Standard__integer.integer, 
 type index_rep_type = int, 
 function to_rep = Standard__integer__rep.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Standard__integer.in_range, 
 predicate index_dynamic_property = Standard__positive.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type string =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline:no" function to_array
 
 meta "model_projection" function first
 
 meta "inline:no" function first
 
 meta "model_projection" function last
 
 meta "inline:no" function last
 
 type string__ref =
  { mutable string__content : string }
 
 function string__ref_string__content__projection 
   (a : string__ref) : string =
  a.string__content
 
 meta "model_projection" function string__ref_string__content__projection
 
 meta "inline:no" function string__ref_string__content__projection
 
 val string__havoc 
   (x : string__ref) : unit
  writes {x}

end

(* Module for declaring a program function (and possibly an axiom) for "put_line__2" defined at a-textio.ads:508, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada___ada__text_io__put_line__2___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        Standard__string as Standard__string
 use        Ada___ada__text_io__line_length__2 as Ada___ada__text_io__line_length__2
 use        Ada___ada__text_io__page_length__2 as Ada___ada__text_io__page_length__2
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err
 use        Ada___ada__text_io__standard_in as Ada___ada__text_io__standard_in
 use        Ada___ada__text_io__file_system as Ada___ada__text_io__file_system
 use        Ada___ada__text_io__standard_out as Ada___ada__text_io__standard_out
 use        Ada___ada__text_io__standard_err as Ada___ada__text_io__standard_err
 use        Ada___ada__text_io__current_in as Ada___ada__text_io__current_in
 use        Ada___ada__text_io__current_out as Ada___ada__text_io__current_out
 use        Ada___ada__text_io__current_err as Ada___ada__text_io__current_err

 val put_line__2 
   (item : Standard__string.string) : unit
  requires {  true }
  ensures {  ( ( [@GP_Pretty_Ada:6090] ((old (Ada___ada__text_io__line_length__2.line_length__2 Ada___ada__text_io__standard_in.standard_in.Main.__private__content Ada___ada__text_io__file_system.file_system.Main.__private__content Ada___ada__text_io__standard_out.standard_out.Main.__private__content Ada___ada__text_io__standard_err.standard_err.Main.__private__content Ada___ada__text_io__current_in.current_in.Main.__private__content Ada___ada__text_io__current_out.current_out.Main.__private__content Ada___ada__text_io__current_err.current_err.Main.__private__content) ) = (Ada___ada__text_io__line_length__2.line_length__2 Ada___ada__text_io__standard_in.standard_in.Main.__private__content Ada___ada__text_io__file_system.file_system.Main.__private__content Ada___ada__text_io__standard_out.standard_out.Main.__private__content Ada___ada__text_io__standard_err.standard_err.Main.__private__content Ada___ada__text_io__current_in.current_in.Main.__private__content Ada___ada__text_io__current_out.current_out.Main.__private__content Ada___ada__text_io__current_err.current_err.Main.__private__content)) ) /\ ( [@GP_Pretty_Ada:6096] ((old (Ada___ada__text_io__page_length__2.page_length__2 Ada___ada__text_io__standard_in.standard_in.Main.__private__content Ada___ada__text_io__file_system.file_system.Main.__private__content Ada___ada__text_io__standard_out.standard_out.Main.__private__content Ada___ada__text_io__standard_err.standard_err.Main.__private__content Ada___ada__text_io__current_in.current_in.Main.__private__content Ada___ada__text_io__current_out.current_out.Main.__private__content Ada___ada__text_io__current_err.current_err.Main.__private__content) ) = (Ada___ada__text_io__page_length__2.page_length__2 Ada___ada__text_io__standard_in.standard_in.Main.__private__content Ada___ada__text_io__file_system.file_system.Main.__private__content Ada___ada__text_io__standard_out.standard_out.Main.__private__content Ada___ada__text_io__standard_err.standard_err.Main.__private__content Ada___ada__text_io__current_in.current_in.Main.__private__content Ada___ada__text_io__current_out.current_out.Main.__private__content Ada___ada__text_io__current_err.current_err.Main.__private__content)) ) ) }
  reads {Ada___ada__text_io__standard_in.standard_in, Ada___ada__text_io__file_system.file_system, Ada___ada__text_io__standard_out.standard_out, Ada___ada__text_io__standard_err.standard_err, Ada___ada__text_io__current_in.current_in, Ada___ada__text_io__current_out.current_out, Ada___ada__text_io__current_err.current_err}
  writes {Ada___ada__text_io__standard_in.standard_in, Ada___ada__text_io__file_system.file_system, Ada___ada__text_io__standard_out.standard_out, Ada___ada__text_io__standard_err.standard_err, Ada___ada__text_io__current_in.current_in, Ada___ada__text_io__current_out.current_out, Ada___ada__text_io__current_err.current_err}

end

(* Module defining to_string/of_string functions, created in Gnat2Why.Types.Translate_Type *)
module Standard_String__Img
 use        "int".Int
 use        Standard__string as Standard__string
 use        "_gnatprove_standard".Main
 use        "int".Int

 val function to_string 
   (x : Main.__image) (s : int) : Standard__string.string
 
 val function from_string 
   (x : Standard__string.string) : Main.__image
 
 axiom to_string__first :
  (forall x   : Main.__image.
  (forall s   : int [(to_string x s)].
   ((Standard__string.first (to_string x s)) = (1 : int))))
 
 axiom to_string__length :
  (forall x   : Main.__image.
  (forall s   : int [(to_string x s)].
   ( (s >= (0 : int)) -> ((Standard__string.length (to_string x s)) <= s) )))

end

(* Module for axiomatizing concatenation for the array theory associated to type "string", created in Why.Gen.Arrays.Declare_Concatenation_Symbols *)
module Array__Int__Standard__character__Concat
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Array__Int__Standard__character as Array__Int__Standard__character

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "_gnatprove_standard".Array__1__Concat with axiom .,
 type component_type = Array__Int__Standard__character.component_type, 
 type map = Array__Int__Standard__character.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Standard__character.get

end

(* Module giving axioms for type "map" defined at main.adb:12, created in Gnat2Why.Types.Generate_Type_Completion *)
module Main__map___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed

 predicate dynamic_invariant [@inline] 
   (temp___expr_238 : Array__Int_Int__Main__int_needed.map) (temp___is_init_234 : bool) (temp___skip_constant_235 : bool) (temp___do_toplevel_236 : bool) (temp___do_typ_inv_237 : bool) =
  true
 val dynamic_invariant [@inline] 
   (temp___expr_238 : Array__Int_Int__Main__int_needed.map) (temp___is_init_234 : bool) (temp___skip_constant_235 : bool) (temp___do_toplevel_236 : bool) (temp___do_typ_inv_237 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_238 : Array__Int_Int__Main__int_needed.map) (temp___is_init_234 : bool) (temp___skip_constant_235 : bool) (temp___do_toplevel_236 : bool) (temp___do_typ_inv_237 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_241 : Array__Int_Int__Main__int_needed.map) (temp___skip_top_level_242 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_241 : Array__Int_Int__Main__int_needed.map) (temp___skip_top_level_242 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_241 : Array__Int_Int__Main__int_needed.map) (temp___skip_top_level_242 : bool) }

end

(* Module for defining a value for string literal  defined at main.adb:64, created in Gnat2Why.Expr.Transform_String_Literal *)
module Temp___String_Literal_259
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__character as Standard__character
 use        Standard__character__rep as Standard__character__rep
 use        Array__Int__Standard__character as Array__Int__Standard__character
 use        Array__Int__Standard__character as Array__Int__Standard__character

 val function temp___String_Literal_259 
   (__void_param : unit) : Array__Int__Standard__character.map
 
 axiom temp___String_Literal_259__def_axiom :
  (forall __void_param   : unit [(temp___String_Literal_259 __void_param)].
   ( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (1 : int))) = (84 : int)) /\ ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (2 : int))) = (104 : int)) )/\( ( ( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (3 : int))) = (101 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (4 : int))) = (32 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (5 : int))) = (114 : int)) )/\( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (6 : int))) = (101 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (7 : int))) = (115 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (8 : int))) = (117 : int)) ) )/\( ( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (9 : int))) = (108 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (10 : int))) = (116 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (11 : int))) = (32 : int)) )/\( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (12 : int))) = (105 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (13 : int))) = (115 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_259 __void_param) (14 : int))) = (58 : int)) ) ) ) ))

end

(* Module giving axioms for type "positive", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__positive___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__positive as Standard__positive

 predicate dynamic_invariant [@inline] 
   (temp___expr_46 : int) (temp___is_init_42 : bool) (temp___skip_constant_43 : bool) (temp___do_toplevel_44 : bool) (temp___do_typ_inv_45 : bool) =
  (if (( temp___is_init_42 \/ (Standard__positive.first <= Standard__positive.last) )) then (
   (Standard__positive.dynamic_property Standard__positive.first Standard__positive.last temp___expr_46)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_46 : int) (temp___is_init_42 : bool) (temp___skip_constant_43 : bool) (temp___do_toplevel_44 : bool) (temp___do_typ_inv_45 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_46 : int) (temp___is_init_42 : bool) (temp___skip_constant_43 : bool) (temp___do_toplevel_44 : bool) (temp___do_typ_inv_45 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_47 : int) (temp___skip_top_level_48 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_47 : int) (temp___skip_top_level_48 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_47 : int) (temp___skip_top_level_48 : bool) }

end

(* Module giving axioms for type "character", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__character___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__character as Standard__character

 predicate dynamic_invariant [@inline] 
   (temp___expr_74 : int) (temp___is_init_70 : bool) (temp___skip_constant_71 : bool) (temp___do_toplevel_72 : bool) (temp___do_typ_inv_73 : bool) =
  (if (( temp___is_init_70 \/ (Standard__character.first <= Standard__character.last) )) then (
   (Standard__character.dynamic_property Standard__character.first Standard__character.last temp___expr_74)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_74 : int) (temp___is_init_70 : bool) (temp___skip_constant_71 : bool) (temp___do_toplevel_72 : bool) (temp___do_typ_inv_73 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_74 : int) (temp___is_init_70 : bool) (temp___skip_constant_71 : bool) (temp___do_toplevel_72 : bool) (temp___do_typ_inv_73 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_75 : int) (temp___skip_top_level_76 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_75 : int) (temp___skip_top_level_76 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_75 : int) (temp___skip_top_level_76 : bool) }

end

(* Module giving axioms for type "string", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__string___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Standard__positive as Standard__positive
 use        Standard__string as Standard__string

 predicate dynamic_invariant [@inline] 
   (temp___expr_96 : Standard__string.string) (temp___is_init_92 : bool) (temp___skip_constant_93 : bool) (temp___do_toplevel_94 : bool) (temp___do_typ_inv_95 : bool) =
  (if (temp___skip_constant_93) then (
   true) else (
   (Standard__string.dynamic_property Standard__positive.first Standard__positive.last (Standard__string.first temp___expr_96) (Standard__string.last temp___expr_96))))
 val dynamic_invariant [@inline] 
   (temp___expr_96 : Standard__string.string) (temp___is_init_92 : bool) (temp___skip_constant_93 : bool) (temp___do_toplevel_94 : bool) (temp___do_typ_inv_95 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_96 : Standard__string.string) (temp___is_init_92 : bool) (temp___skip_constant_93 : bool) (temp___do_toplevel_94 : bool) (temp___do_typ_inv_95 : bool) }

end

(* Module for checking contracts and absence of run-time errors in subprogram "main" defined at main.adb:2, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Main__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Integer as Integer
 use        Standard_String__Img as Standard_String__Img
 use        Standard__integer as Standard__integer
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Standard__positive as Standard__positive
 use        Array__Int__Standard__character__Concat as Array__Int__Standard__character__Concat
 use        Standard__string as Standard__string
 use        Main__n as Main__n
 use        Main__m as Main__m
 use        Main__count_islands___axiom as Main__count_islands___axiom
 use        Main__map_array as Main__map_array
 use        Ada___ada__text_io__put_line__2___axiom as Ada___ada__text_io__put_line__2___axiom
 use        Main__map___axiom as Main__map___axiom
 use        Main__map_array__aggregate_def as Main__map_array__aggregate_def
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Temp___String_Literal_259 as Temp___String_Literal_259
 use        Array__Int__Standard__character as Array__Int__Standard__character
 use        Array__Int__Standard__character as Array__Int__Standard__character
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Standard__positive___axiom as Standard__positive___axiom
 use        Standard__character___axiom as Standard__character___axiom
 use        Standard__string___axiom as Standard__string___axiom
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Main__n___axiom as Main__n___axiom
 use        Main__m___axiom as Main__m___axiom
 use        Main__int_needed___axiom as Main__int_needed___axiom
 use        Main__map___axiom as Main__map___axiom
 use        Main__map_array___axiom as Main__map_array___axiom
 use        Main__map_array__aggregate_def___axiom as Main__map_array__aggregate_def___axiom
 use        Ada___ada__text_io__count___axiom as Ada___ada__text_io__count___axiom
 use        Ada___ada__text_io__line_length__2___axiom as Ada___ada__text_io__line_length__2___axiom
 use        Ada___ada__text_io__page_length__2___axiom as Ada___ada__text_io__page_length__2___axiom
 use        Ada___ada__text_io__put_line__2___axiom as Ada___ada__text_io__put_line__2___axiom
 use        Main__count_islands___axiom as Main__count_islands___axiom

 let def [#"main.adb" 2 0 0][@GP_Subp:main.adb:2] 
   (__void_param : unit)
  requires { [#"main.adb" 2 0 0] true }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram main.adb:2 *)
  ;
  () (* Declarations introduced by the compiler at the beginning of the subprogram main.adb:2 *)
  ;
  () (* Check for RTE in the Pre of the subprogram main.adb:2 *)
  ;
  [#"main.adb" 2 0 0] begin ensures {true} let _ = (let _  = True in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram main.adb:2 *)
  ;
  [#"main.adb" 2 0 0] try
   ( ();
   ([#"main.adb" 3 0 0] ());
   ([#"main.adb" 5 0 0] ( [#"main.adb" 5 0 0] begin ensures {true} let _ = (let _  = (4 : int) in (
    ()))
    in () end ;
   [#"main.adb" 5 0 0] assume { [#"main.adb" 5 0 0] (Standard__integer___axiom.dynamic_invariant Main__n.n True False True True) } ));
   ([#"main.adb" 6 0 0] ( [#"main.adb" 6 0 0] begin ensures {true} let _ = (let _  = (5 : int) in (
    ()))
    in () end ;
   [#"main.adb" 6 0 0] assume { [#"main.adb" 6 0 0] (Standard__integer___axiom.dynamic_invariant Main__m.m True False True True) } ));
   ([#"main.adb" 7 0 0] ());
   ([#"main.adb" 8 0 0] ());
   ([#"main.adb" 10 0 0] ());
   ([#"main.adb" 12 0 0] ());
   ([#"main.adb" 14 0 0] ());
   ([#"main.adb" 14 0 0] ());
   ([#"main.adb" 14 0 0] ());
   ([#"main.adb" 14 0 0] ());
   ([#"main.adb" 14 0 0] ());
   ([#"main.adb" 14 0 0] ());
   ([#"main.adb" 14 0 0] ());
   ([#"main.adb" 16 0 0] ());
   ([#"main.adb" 16 0 0] ());
   ([#"main.adb" 16 0 0] ());
   ([#"main.adb" 38 0 0] ());
   ([#"main.adb" 38 0 0] ());
   ([#"main.adb" 38 0 0] ());
   ([#"main.adb" 58 0 0] ( (let main__map_array__assume  = (Main__map_array__aggregate_def.main__map_array__aggregate_def((1 : int)) ((0 : int)) ((1 : int)) ((1 : int)) ((0 : int)) ((1 : int)) ((0 : int)) ((0 : int)) ((1 : int)) ((0 : int)) ((1 : int)) ((1 : int)) ((0 : int)) ((1 : int)) ((0 : int)) ((0 : int)) ((0 : int)) ((1 : int)) ((0 : int)) ((0 : int))) in (
    [#"main.adb" 58 0 0] assume { [#"main.adb" 58 0 0] (main__map_array__assume = Main__map_array.map_array) }))
   ;
   [#"main.adb" 58 0 0] assume { [#"main.adb" 58 0 0] (Main__map___axiom.dynamic_invariant Main__map_array.map_array True False True True) } ));
   ();
   ( [@GP_Sloc:main.adb:64:32] ([#"main.adb" 64 0 0] ()) );
   ( [@GP_Sloc:main.adb:64:4] ([#"main.adb" 64 0 0] ()) );
   ( [@GP_Sloc:main.adb:64:4] ([#"main.adb" 64 0 0] ( (Ada___ada__text_io__put_line__2___axiom.put_line__2((let temp___261 [@mlw:proxy_symbol] [@introduced]  = (Standard_String__Img.to_string((Standard__integer.attr__ATTRIBUTE_IMAGE((Main__count_islands___axiom.count_islands(Main__map_array.map_array))))) ((12 : int))) in (
   (let temp___260 [@mlw:proxy_symbol] [@introduced]  = (Temp___String_Literal_259.temp___String_Literal_259(())) in (
    (Standard__string.of_array((Array__Int__Standard__character__Concat.concat(temp___260) ((1 : int)) ((14 : int)) ((Standard__string.to_array(temp___261))) ((Standard__string.first(temp___261))) ((Standard__string.last(temp___261))))) ((1 : int)) (([#"main.adb" 64 0 0] ( [@comment:   Put_Line("The result is:" & Count_Islands(Map_Array)'Img);                              ^ main.adb:64:30:VC_RANGE_CHECK] [@GP_Sloc:main.adb:64:30] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Id:0] [@GP_Shape:call_put_line__2__concat] (Standard__positive.range_check_((((1 : int) + ((Integer.length((1 : int)) ((14 : int))) + (Integer.length((Standard__string.first(temp___261))) ((Standard__string.last(temp___261)))))) - (1 : int)))) ))))))
   ))
   )) )) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _  = True in (
   ()))
   in () end  )
end

(* Module for defining the constant "map_array" defined at main.adb:16, created in Gnat2Why.Decls.Translate_Constant *)
module Main__visit_islands__map_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed

 val constant map_array [#"main.adb" 16 0 0][@model_trace:17722] [@model_projected] [@name:Map_Array] 
   : Array__Int_Int__Main__int_needed.map

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the constant "i" defined at main.adb:16, created in Gnat2Why.Decls.Translate_Constant *)
module Main__visit_islands__i
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant i [#"main.adb" 16 0 0][@name:i] [@model_trace:17729] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the constant "j" defined at main.adb:16, created in Gnat2Why.Decls.Translate_Constant *)
module Main__visit_islands__j
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant j [#"main.adb" 16 0 0][@model_trace:17736] [@name:j] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the constant "visited_array" defined at main.adb:16, created in Gnat2Why.Decls.Translate_Constant *)
module Main__visit_islands__visited_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val constant visited_array [#"main.adb" 16 0 0][@model_projected] [@name:Visited_Array] [@model_trace:17743] 
   : Array__Int_Int__Bool.map

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "matrix" defined at main.adb:18, created in Gnat2Why.Decls.Translate_Variable *)
module Main__visit_islands__matrix
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed

 val matrix [#"main.adb" 18 0 0][@model_projected] [@name:Matrix] [@model_trace:2451]  : Array__Int_Int__Main__int_needed.map__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "vis_array" defined at main.adb:19, created in Gnat2Why.Decls.Translate_Variable *)
module Main__visit_islands__vis_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val vis_array [#"main.adb" 19 0 0][@name:Vis_Array] [@model_projected] [@model_trace:2461]  : Array__Int_Int__Bool.map__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for axiomatizing type "n_range" defined at main.adb:7, created in Gnat2Why.Types.Translate_Type *)
module Main__n_range
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type n_range =
  < range 1 4 >
 
 val constant first 
   : int
  ensures { result =  (1 : int) }
 
 val constant last 
   : int
  ensures { result =  (4 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = n_range, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type n_range__ref =
  { mutable n_range__content : n_range }
 
 function n_range__ref_n_range__content__projection 
   (a : n_range__ref) : n_range =
  a.n_range__content
 
 meta "model_projection" function n_range__ref_n_range__content__projection
 
 meta "inline:no" function n_range__ref_n_range__content__projection
 
 val n_range__havoc 
   (x : n_range__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "m_range" defined at main.adb:8, created in Gnat2Why.Types.Translate_Type *)
module Main__m_range
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type m_range =
  < range 1 5 >
 
 val constant first 
   : int
  ensures { result =  (1 : int) }
 
 val constant last 
   : int
  ensures { result =  (5 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = m_range, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type m_range__ref =
  { mutable m_range__content : m_range }
 
 function m_range__ref_m_range__content__projection 
   (a : m_range__ref) : m_range =
  a.m_range__content
 
 meta "model_projection" function m_range__ref_m_range__content__projection
 
 meta "inline:no" function m_range__ref_m_range__content__projection
 
 val m_range__havoc 
   (x : m_range__ref) : unit
  writes {x}

end

(* Module giving axioms for type "n_range" defined at main.adb:7, created in Gnat2Why.Types.Generate_Type_Completion *)
module Main__n_range___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Main__n_range as Main__n_range

 predicate dynamic_invariant [@inline] 
   (temp___expr_217 : int) (temp___is_init_213 : bool) (temp___skip_constant_214 : bool) (temp___do_toplevel_215 : bool) (temp___do_typ_inv_216 : bool) =
  (if (( temp___is_init_213 \/ (Main__n_range.first <= Main__n_range.last) )) then (
   (Main__n_range.dynamic_property Main__n_range.first Main__n_range.last temp___expr_217)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_217 : int) (temp___is_init_213 : bool) (temp___skip_constant_214 : bool) (temp___do_toplevel_215 : bool) (temp___do_typ_inv_216 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_217 : int) (temp___is_init_213 : bool) (temp___skip_constant_214 : bool) (temp___do_toplevel_215 : bool) (temp___do_typ_inv_216 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_218 : int) (temp___skip_top_level_219 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_218 : int) (temp___skip_top_level_219 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_218 : int) (temp___skip_top_level_219 : bool) }

end

(* Module giving axioms for type "m_range" defined at main.adb:8, created in Gnat2Why.Types.Generate_Type_Completion *)
module Main__m_range___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Main__m_range as Main__m_range

 predicate dynamic_invariant [@inline] 
   (temp___expr_224 : int) (temp___is_init_220 : bool) (temp___skip_constant_221 : bool) (temp___do_toplevel_222 : bool) (temp___do_typ_inv_223 : bool) =
  (if (( temp___is_init_220 \/ (Main__m_range.first <= Main__m_range.last) )) then (
   (Main__m_range.dynamic_property Main__m_range.first Main__m_range.last temp___expr_224)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_224 : int) (temp___is_init_220 : bool) (temp___skip_constant_221 : bool) (temp___do_toplevel_222 : bool) (temp___do_typ_inv_223 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_224 : int) (temp___is_init_220 : bool) (temp___skip_constant_221 : bool) (temp___do_toplevel_222 : bool) (temp___do_typ_inv_223 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_225 : int) (temp___skip_top_level_226 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_225 : int) (temp___skip_top_level_226 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_225 : int) (temp___skip_top_level_226 : bool) }

end

(* Module giving an empty axiom for the entity "matrix" defined at main.adb:18, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__visit_islands__matrix___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "vis_array" defined at main.adb:19, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__visit_islands__vis_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "map_array" defined at main.adb:16, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__visit_islands__map_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "i" defined at main.adb:16, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__visit_islands__i___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "j" defined at main.adb:16, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__visit_islands__j___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "visited_array" defined at main.adb:16, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__visit_islands__visited_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for checking contracts and absence of run-time errors in subprogram "visit_islands" defined at main.adb:16, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Main__visit_islands__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Boolean as Boolean
 use        Standard__integer as Standard__integer
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Main__visit_islands__map_array as Main__visit_islands__map_array
 use        Main__visit_islands__i as Main__visit_islands__i
 use        Main__visit_islands__j as Main__visit_islands__j
 use        Main__visit_islands__visited_array as Main__visit_islands__visited_array
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Main__visit_islands___axiom as Main__visit_islands___axiom
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Main__visit_islands__matrix as Main__visit_islands__matrix
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Main__visit_islands__vis_array as Main__visit_islands__vis_array
 use        Main__n_range as Main__n_range
 use        Main__m_range as Main__m_range
 use        Main__int_needed as Main__int_needed
 use        Main__int_needed__rep as Main__int_needed__rep
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Main__map___axiom as Main__map___axiom
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Main__visited___axiom as Main__visited___axiom
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Main__n_range___axiom as Main__n_range___axiom
 use        Main__m_range___axiom as Main__m_range___axiom
 use        Main__int_needed___axiom as Main__int_needed___axiom
 use        Main__map___axiom as Main__map___axiom
 use        Main__visited___axiom as Main__visited___axiom
 use        Main__visit_islands__matrix___axiom as Main__visit_islands__matrix___axiom
 use        Main__visit_islands__vis_array___axiom as Main__visit_islands__vis_array___axiom
 use        Main__visit_islands___axiom as Main__visit_islands___axiom
 use        Main__visit_islands__map_array___axiom as Main__visit_islands__map_array___axiom
 use        Main__visit_islands__i___axiom as Main__visit_islands__i___axiom
 use        Main__visit_islands__j___axiom as Main__visit_islands__j___axiom
 use        Main__visit_islands__visited_array___axiom as Main__visit_islands__visited_array___axiom

 val main__visit_islands__result [@model_projected] [@name:Visit_Islands] [@model_trace:17715@result]  : Array__Int_Int__Bool.map__ref 
 
 let def [#"main.adb" 16 0 0][@GP_Subp:main.adb:16] 
   (__void_param : unit)
  requires { [#"main.adb" 16 0 0] true }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram main.adb:16 *)
  ;
  [#"main.adb" 16 0 0] assume { [#"main.adb" 16 0 0] (Main__map___axiom.dynamic_invariant Main__visit_islands__map_array.map_array True False True True) };
  [#"main.adb" 16 0 0] assume { [#"main.adb" 16 0 0] (Standard__integer___axiom.dynamic_invariant Main__visit_islands__i.i True False True True) };
  [#"main.adb" 16 0 0] assume { [#"main.adb" 16 0 0] (Standard__integer___axiom.dynamic_invariant Main__visit_islands__j.j True False True True) };
  [#"main.adb" 16 0 0] assume { [#"main.adb" 16 0 0] (Main__visited___axiom.dynamic_invariant Main__visit_islands__visited_array.visited_array True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram main.adb:16 *)
  ;
  () (* Check for RTE in the Pre of the subprogram main.adb:16 *)
  ;
  [#"main.adb" 16 0 0] begin ensures {true} let _ = (let _  = True in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram main.adb:16 *)
  ;
  [#"main.adb" 16 0 0] try
   ( ();
   ([#"main.adb" 18 0 0] ( [#"main.adb" 18 0 0] (Main__visit_islands__matrix.matrix.Array__Int_Int__Main__int_needed.map__content <- ( Main__visit_islands__map_array.map_array ));
   [#"main.adb" 18 0 0] assume { [#"main.adb" 18 0 0] (Main__map___axiom.dynamic_invariant Main__visit_islands__matrix.matrix.Array__Int_Int__Main__int_needed.map__content True False True True) } ));
   ([#"main.adb" 19 0 0] ( [#"main.adb" 19 0 0] (Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( Main__visit_islands__visited_array.visited_array ));
   [#"main.adb" 19 0 0] assume { [#"main.adb" 19 0 0] (Main__visited___axiom.dynamic_invariant Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content True False True True) } ));
   ();
   ( [@GP_Sloc:main.adb:24:7] ([#"main.adb" 24 0 0] (if (( ([#"main.adb" 24 0 0] [#"main.adb" 24 0 0] (([@branch_id=2472] Main.spark__branch).bool__content <- ( ( ( ( ( ( (Main__visit_islands__i.i < (1 : int)) || (Main__visit_islands__j.j < (1 : int)) ) || (Main__visit_islands__i.i > (4 : int)) ) || (Main__visit_islands__j.j > (5 : int)) ) || ((Boolean.to_int((Array__Int_Int__Bool.get(Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content) (( [#"main.adb" 24 0 0] assert { [#"main.adb" 24 0 0] ([#"main.adb" 24 0 0] ( [@GP_Sloc:main.adb:24:76] [@vc:annotation] [@comment:      if i < 1 or else j < 1 or else i > N or else j > M or else Vis_Array(i, j)=True or else Matrix(i,j)=0 then                                                                            ^ main.adb:24:76:VC_INDEX_CHECK] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:1] [@GP_Shape:if__orelse__orelse__cmp__ixdcomp] ( (Main__n_range.first <= Main__visit_islands__i.i) /\ (Main__visit_islands__i.i <= Main__n_range.last) ) )) };
   Main__visit_islands__i.i )) ((  assert {  ([#"main.adb" 24 0 0] ( [@comment:      if i < 1 or else j < 1 or else i > N or else j > M or else Vis_Array(i, j)=True or else Matrix(i,j)=0 then                                                                               ^ main.adb:24:79:VC_INDEX_CHECK] [@GP_Sloc:main.adb:24:79] [@vc:annotation] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:2] [@GP_Shape:if__orelse__orelse__cmp__ixdcomp] ( (Main__m_range.first <= Main__visit_islands__j.j) /\ (Main__visit_islands__j.j <= Main__m_range.last) ) )) };
   Main__visit_islands__j.j ))))) = (Boolean.to_int((Boolean.of_int((1 : int)))))) ) || ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__visit_islands__matrix.matrix.Array__Int_Int__Main__int_needed.map__content) ((  assert {  ([#"main.adb" 24 0 0] ( [@GP_Sloc:main.adb:24:102] [@vc:annotation] [@GP_Shape:if__orelse__cmp__ixdcomp] [@GP_Reason:VC_INDEX_CHECK] [@comment:      if i < 1 or else j < 1 or else i > N or else j > M or else Vis_Array(i, j)=True or else Matrix(i,j)=0 then                                                                                                      ^ main.adb:24:102:VC_INDEX_CHECK] [@GP_Id:3] ( (Main__n_range.first <= Main__visit_islands__i.i) /\ (Main__visit_islands__i.i <= Main__n_range.last) ) )) };
   Main__visit_islands__i.i )) ((  assert {  ([#"main.adb" 24 0 0] ( [@GP_Sloc:main.adb:24:104] [@vc:annotation] [@comment:      if i < 1 or else j < 1 or else i > N or else j > M or else Vis_Array(i, j)=True or else Matrix(i,j)=0 then                                                                                                        ^ main.adb:24:104:VC_INDEX_CHECK] [@GP_Shape:if__orelse__cmp__ixdcomp] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:4] ( (Main__m_range.first <= Main__visit_islands__j.j) /\ (Main__visit_islands__j.j <= Main__m_range.last) ) )) };
   Main__visit_islands__j.j ))))) = (0 : int)) ) )));
   ( [@branch_id=2472] Main.spark__branch ).bool__content )) then (
    ( ();
    ( [@GP_Sloc:main.adb:25:17] ([#"main.adb" 25 0 0] ()) );
    ( [@GP_Sloc:main.adb:25:10] ([#"main.adb" 25 0 0] ( [#"main.adb" 25 0 0] (main__visit_islands__result.Array__Int_Int__Bool.map__content <- ( Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content ));
    [#"main.adb" 25 0 0] raise Return__exc )) ) )) else (
    ()))) );
   ( [@GP_Sloc:main.adb:28:7] ([#"main.adb" 28 0 0] ()) );
   ( [@GP_Sloc:main.adb:28:23] ([#"main.adb" 28 0 0] [#"main.adb" 28 0 0] (Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( (Array__Int_Int__Bool.set(Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content) (( [#"main.adb" 28 0 0] assert { [#"main.adb" 28 0 0] ([#"main.adb" 28 0 0] ( [@GP_Sloc:main.adb:28:17] [@GP_Shape:vis_array_assign__ixdcomp] [@vc:annotation] [@comment:      Vis_Array(i, j) := True;                 ^ main.adb:28:17:VC_INDEX_CHECK] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:5] ( (Main__n_range.first <= Main__visit_islands__i.i) /\ (Main__visit_islands__i.i <= Main__n_range.last) ) )) };
   Main__visit_islands__i.i )) ((  assert {  ([#"main.adb" 28 0 0] ( [@GP_Shape:vis_array_assign__ixdcomp] [@vc:annotation] [@comment:      Vis_Array(i, j) := True;                    ^ main.adb:28:20:VC_INDEX_CHECK] [@GP_Reason:VC_INDEX_CHECK] [@GP_Sloc:main.adb:28:20] [@GP_Id:6] ( (Main__m_range.first <= Main__visit_islands__j.j) /\ (Main__visit_islands__j.j <= Main__m_range.last) ) )) };
   Main__visit_islands__j.j )) ((Boolean.of_int((1 : int))))) ))) );
   ( [@GP_Sloc:main.adb:30:7] ([#"main.adb" 30 0 0] ()) );
   ( [@GP_Sloc:main.adb:30:34] ([#"main.adb" 30 0 0] ()) );
   ( [@GP_Sloc:main.adb:30:53] ([#"main.adb" 30 0 0] ()) );
   ( [@GP_Sloc:main.adb:30:20] ([#"main.adb" 30 0 0] ()) );
   ( [@GP_Sloc:main.adb:30:17] ([#"main.adb" 30 0 0] [#"main.adb" 30 0 0] (Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__visit_islands__matrix.matrix.Array__Int_Int__Main__int_needed.map__content) (([#"main.adb" 30 0 0] ( [@GP_Sloc:main.adb:30:45] [@vc:annotation] [@GP_Reason:VC_OVERFLOW_CHECK] [@GP_Shape:vis_array_assign__call_visit_islands__add] [@comment:      Vis_Array := Visit_Islands(Matrix,  i + 1, j, Vis_Array);                                             ^ main.adb:30:45:VC_OVERFLOW_CHECK] [@GP_Id:7] (Standard__integer.range_check_((Main__visit_islands__i.i + (1 : int)))) ))) (Main__visit_islands__j.j) (Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content)) ))) );
   ( [@GP_Sloc:main.adb:31:7] ([#"main.adb" 31 0 0] ()) );
   ( [@GP_Sloc:main.adb:31:34] ([#"main.adb" 31 0 0] ()) );
   ( [@GP_Sloc:main.adb:31:53] ([#"main.adb" 31 0 0] ()) );
   ( [@GP_Sloc:main.adb:31:20] ([#"main.adb" 31 0 0] ()) );
   ( [@GP_Sloc:main.adb:31:17] ([#"main.adb" 31 0 0] [#"main.adb" 31 0 0] (Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__visit_islands__matrix.matrix.Array__Int_Int__Main__int_needed.map__content) (([#"main.adb" 31 0 0] ( [@vc:annotation] [@GP_Reason:VC_OVERFLOW_CHECK] [@GP_Sloc:main.adb:31:45] [@GP_Shape:vis_array_assign__call_visit_islands__sub] [@GP_Id:8] [@comment:      Vis_Array := Visit_Islands(Matrix,  i - 1, j, Vis_Array);                                             ^ main.adb:31:45:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__visit_islands__i.i - (1 : int)))) ))) (Main__visit_islands__j.j) (Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content)) ))) );
   ( [@GP_Sloc:main.adb:32:7] ([#"main.adb" 32 0 0] ()) );
   ( [@GP_Sloc:main.adb:32:34] ([#"main.adb" 32 0 0] ()) );
   ( [@GP_Sloc:main.adb:32:53] ([#"main.adb" 32 0 0] ()) );
   ( [@GP_Sloc:main.adb:32:20] ([#"main.adb" 32 0 0] ()) );
   ( [@GP_Sloc:main.adb:32:17] ([#"main.adb" 32 0 0] [#"main.adb" 32 0 0] (Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__visit_islands__matrix.matrix.Array__Int_Int__Main__int_needed.map__content) (Main__visit_islands__i.i) (([#"main.adb" 32 0 0] ( [@GP_Sloc:main.adb:32:48] [@vc:annotation] [@GP_Reason:VC_OVERFLOW_CHECK] [@GP_Shape:vis_array_assign__call_visit_islands__add] [@comment:      Vis_Array := Visit_Islands(Matrix,  i, j + 1, Vis_Array);                                                ^ main.adb:32:48:VC_OVERFLOW_CHECK] [@GP_Id:9] (Standard__integer.range_check_((Main__visit_islands__j.j + (1 : int)))) ))) (Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content)) ))) );
   ( [@GP_Sloc:main.adb:33:7] ([#"main.adb" 33 0 0] ()) );
   ( [@GP_Sloc:main.adb:33:34] ([#"main.adb" 33 0 0] ()) );
   ( [@GP_Sloc:main.adb:33:53] ([#"main.adb" 33 0 0] ()) );
   ( [@GP_Sloc:main.adb:33:20] ([#"main.adb" 33 0 0] ()) );
   ( [@GP_Sloc:main.adb:33:17] ([#"main.adb" 33 0 0] [#"main.adb" 33 0 0] (Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__visit_islands__matrix.matrix.Array__Int_Int__Main__int_needed.map__content) (Main__visit_islands__i.i) (([#"main.adb" 33 0 0] ( [@GP_Id:10] [@vc:annotation] [@GP_Reason:VC_OVERFLOW_CHECK] [@GP_Sloc:main.adb:33:48] [@comment:      Vis_Array := Visit_Islands(Matrix,  i, j - 1, Vis_Array);                                                ^ main.adb:33:48:VC_OVERFLOW_CHECK] [@GP_Shape:vis_array_assign__call_visit_islands__sub] (Standard__integer.range_check_((Main__visit_islands__j.j - (1 : int)))) ))) (Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content)) ))) );
   ( [@GP_Sloc:main.adb:35:14] ([#"main.adb" 35 0 0] ()) );
   ( [@GP_Sloc:main.adb:35:7] ([#"main.adb" 35 0 0] ( [#"main.adb" 35 0 0] (main__visit_islands__result.Array__Int_Int__Bool.map__content <- ( Main__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content ));
   [#"main.adb" 35 0 0] raise Return__exc )) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _  = True in (
   ()))
   in () end ;
  main__visit_islands__result.Array__Int_Int__Bool.map__content )
end

(* Module for declaring an abstract function for the aggregate at main.adb:40, created in Gnat2Why.Expr.Transform_Aggregate.Generate_Logic_Function *)
module Main__count_islands__visited_array__aggregate_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val function main__count_islands__visited_array__aggregate_def 
   (temp___263 : bool) : Array__Int_Int__Bool.map

end

(* Module for defining the value of the aggregate at main.adb:40, created in Gnat2Why.Expr.Transform_Aggregate.Generate_Logic_Function *)
module Main__count_islands__visited_array__aggregate_def___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Main__count_islands__visited_array__aggregate_def as Main__count_islands__visited_array__aggregate_def
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 axiom def_axiom :
  (forall temp___263   : bool.
   (let temp___262 [@mlw:proxy_symbol] [@introduced]  = (Main__count_islands__visited_array__aggregate_def.main__count_islands__visited_array__aggregate_def temp___263) in (
    (forall temp___264   temp___265   : int.
     ((Array__Int_Int__Bool.get temp___262 temp___264 temp___265) = temp___263))))
  )

end

(* Module for defining the constant "map_array" defined at main.adb:38, created in Gnat2Why.Decls.Translate_Constant *)
module Main__count_islands__map_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed

 val constant map_array [#"main.adb" 38 0 0][@model_trace:17848] [@model_projected] [@name:Map_Array] 
   : Array__Int_Int__Main__int_needed.map

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "visited_array" defined at main.adb:40, created in Gnat2Why.Decls.Translate_Variable *)
module Main__count_islands__visited_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val visited_array [#"main.adb" 40 0 0][@model_projected] [@name:Visited_Array] [@model_trace:2573]  : Array__Int_Int__Bool.map__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "count" defined at main.adb:41, created in Gnat2Why.Decls.Translate_Variable *)
module Main__count_islands__count
 use        "_gnatprove_standard".Main
 use        "int".Int

 val count [#"main.adb" 41 0 0][@model_projected] [@model_trace:2589] [@name:Count]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "i" defined at main.adb:46, created in Gnat2Why.Decls.Translate_Variable *)
module Main__count_islands__L_1__i
 use        "_gnatprove_standard".Main
 use        "int".Int

 val i [#"main.adb" 46 0 0][@name:i] [@model_projected] [@model_trace:2610]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "j" defined at main.adb:47, created in Gnat2Why.Decls.Translate_Variable *)
module Main__count_islands__L_2__j
 use        "_gnatprove_standard".Main
 use        "int".Int

 val j [#"main.adb" 47 0 0][@name:j] [@model_projected] [@model_trace:2623]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the loop exit exception for the loop "L_1" defined at main.adb:46, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Main__count_islands__L_1
 use        "_gnatprove_standard".Main
 use        "int".Int

 exception L_1

end

(* Module for defining the loop exit exception for the loop "L_2" defined at main.adb:47, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Main__count_islands__L_2
 use        "_gnatprove_standard".Main
 use        "int".Int

 exception L_2

end

(* Module giving an empty axiom for the entity "visited_array" defined at main.adb:40, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__count_islands__visited_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "count" defined at main.adb:41, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__count_islands__count___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "i" defined at main.adb:46, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__count_islands__L_1__i___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "j" defined at main.adb:47, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__count_islands__L_2__j___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "L_2" defined at main.adb:47, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__count_islands__L_2___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "L_1" defined at main.adb:46, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__count_islands__L_1___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "map_array" defined at main.adb:38, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Main__count_islands__map_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for checking contracts and absence of run-time errors in subprogram "count_islands" defined at main.adb:38, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Main__count_islands__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Boolean as Boolean
 use        Standard__integer as Standard__integer
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Main__visit_islands___axiom as Main__visit_islands___axiom
 use        Main__count_islands__map_array as Main__count_islands__map_array
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Main__count_islands__visited_array as Main__count_islands__visited_array
 use        Main__count_islands__count as Main__count_islands__count
 use        Main__count_islands__L_1__i as Main__count_islands__L_1__i
 use        Main__count_islands__L_2__j as Main__count_islands__L_2__j
 use        Main__int_needed as Main__int_needed
 use        Main__int_needed__rep as Main__int_needed__rep
 use        Array__Int_Int__Main__int_needed as Array__Int_Int__Main__int_needed
 use        Main__map___axiom as Main__map___axiom
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Main__visited___axiom as Main__visited___axiom
 use        Main__count_islands__L_1 as Main__count_islands__L_1
 use        Main__count_islands__L_2 as Main__count_islands__L_2
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Main__count_islands__visited_array__aggregate_def as Main__count_islands__visited_array__aggregate_def
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Main__int_needed___axiom as Main__int_needed___axiom
 use        Main__map___axiom as Main__map___axiom
 use        Main__visited___axiom as Main__visited___axiom
 use        Main__count_islands__visited_array___axiom as Main__count_islands__visited_array___axiom
 use        Main__count_islands__visited_array__aggregate_def___axiom as Main__count_islands__visited_array__aggregate_def___axiom
 use        Main__count_islands__count___axiom as Main__count_islands__count___axiom
 use        Main__count_islands__L_1__i___axiom as Main__count_islands__L_1__i___axiom
 use        Main__count_islands__L_2__j___axiom as Main__count_islands__L_2__j___axiom
 use        Main__count_islands__L_2___axiom as Main__count_islands__L_2___axiom
 use        Main__count_islands__L_1___axiom as Main__count_islands__L_1___axiom
 use        Main__visit_islands___axiom as Main__visit_islands___axiom
 use        Main__count_islands__map_array___axiom as Main__count_islands__map_array___axiom

 val main__count_islands__result [@model_trace:17841@result] [@model_projected] [@name:Count_Islands]  : int__ref 
 
 let def [#"main.adb" 38 0 0][@GP_Subp:main.adb:38] 
   (__void_param : unit)
  requires { [#"main.adb" 38 0 0] true }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram main.adb:38 *)
  ;
  [#"main.adb" 38 0 0] assume { [#"main.adb" 38 0 0] (Main__map___axiom.dynamic_invariant Main__count_islands__map_array.map_array True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram main.adb:38 *)
  ;
  () (* Check for RTE in the Pre of the subprogram main.adb:38 *)
  ;
  [#"main.adb" 38 0 0] begin ensures {true} let _ = (let _  = True in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram main.adb:38 *)
  ;
  [#"main.adb" 38 0 0] try
   ( ();
   ([#"main.adb" 40 0 0] ( [#"main.adb" 40 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__count_islands__visited_array__aggregate_def.main__count_islands__visited_array__aggregate_def((Boolean.of_int((0 : int))))) ));
   [#"main.adb" 40 0 0] assume { [#"main.adb" 40 0 0] (Main__visited___axiom.dynamic_invariant Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content True False True True) } ));
   ([#"main.adb" 41 0 0] ( [#"main.adb" 41 0 0] (Main__count_islands__count.count.int__content <- ( (0 : int) ));
   [#"main.adb" 41 0 0] assume { [#"main.adb" 41 0 0] (Standard__integer___axiom.dynamic_invariant Main__count_islands__count.count.int__content True False True True) } ));
   ([#"main.adb" 47 0 0] ());
   ([#"main.adb" 46 0 0] ());
   ();
   ( [@GP_Sloc:main.adb:43:7] ([#"main.adb" 43 0 0] (if (( ([#"main.adb" 43 0 0] [#"main.adb" 43 0 0] (([@branch_id=2600] Main.spark__branch).bool__content <- ( (Boolean.of_int((0 : int))) )));
   ( [@branch_id=2600] Main.spark__branch ).bool__content )) then (
    ( ();
    ( [@GP_Sloc:main.adb:44:10] ([#"main.adb" 44 0 0] ( [#"main.adb" 44 0 0] (main__count_islands__result.int__content <- ( (0 : int) ));
    [#"main.adb" 44 0 0] raise Return__exc )) ) )) else (
    ()))) );
   ( [@GP_Sloc:main.adb:46:24] ([#"main.adb" 46 0 0] (let temp___266 [@mlw:proxy_symbol] [@introduced]  = (1 : int) in (
   (let temp___267 [@mlw:proxy_symbol] [@introduced]  = (4 : int) in (
    ( () (* Translation of an unrolled Ada loop from main.adb:46 *)
    ;
    [#"main.adb" 46 0 0] try
     ( [#"main.adb" 46 0 0] begin ensures {true} let _ = (let _  = Main__count_islands__count.count.int__content in (
      ()))
      in () end ;
     (let temp___loop_entry_273  = [#"main.adb" 46 0 0] (val _f : int
     ensures {[#"main.adb" 46 0 0] (result = Main__count_islands__count.count.int__content)} 
     in _f) in (
      ( [#"main.adb" 46 0 0] begin ensures {true} let _ = (let _  = Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content in (
       ()))
       in () end ;
      (let temp___loop_entry_272  = [#"main.adb" 46 0 0] (val _f : Array__Int_Int__Bool.map
      ensures {[#"main.adb" 46 0 0] (result = Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)} 
      in _f) in (
       ( () (* Unrolling of the loop statements of loop main.adb:46 *)
       ;
       [#"main.adb" 46 0 0] (Main__count_islands__L_1__i.i.int__content <- ( (1 : int) ));
       ();
       ( [@GP_Sloc:main.adb:47:27] ([#"main.adb" 47 0 0] (let temp___268 [@mlw:proxy_symbol] [@introduced]  = (1 : int) in (
       (let temp___269 [@mlw:proxy_symbol] [@introduced]  = (5 : int) in (
        ( () (* Translation of an unrolled Ada loop from main.adb:47 *)
        ;
        [#"main.adb" 47 0 0] try
         ( [#"main.adb" 47 0 0] begin ensures {true} let _ = (let _  = Main__count_islands__count.count.int__content in (
          ()))
          in () end ;
         (let temp___loop_entry_271  = [#"main.adb" 47 0 0] (val _f : int
         ensures {[#"main.adb" 47 0 0] (result = Main__count_islands__count.count.int__content)} 
         in _f) in (
          ( [#"main.adb" 47 0 0] begin ensures {true} let _ = (let _  = Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content in (
           ()))
           in () end ;
          (let temp___loop_entry_270  = [#"main.adb" 47 0 0] (val _f : Array__Int_Int__Bool.map
          ensures {[#"main.adb" 47 0 0] (result = Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)} 
          in _f) in (
           ( () (* Unrolling of the loop statements of loop main.adb:47 *)
           ;
           [#"main.adb" 47 0 0] (Main__count_islands__L_2__j.j.int__content <- ( (1 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (2 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (3 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (4 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (5 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) ) )))
           )))
          )
        with
         Main__count_islands__L_2.L_2 -> ()
        end )))
       ))
       ) );
        (Main__count_islands__L_1__i.i.int__content <- ( (2 : int) ));
       ();
       ( [@GP_Sloc:main.adb:47:27] ([#"main.adb" 47 0 0] (let temp___268 [@mlw:proxy_symbol] [@introduced]  = (1 : int) in (
       (let temp___269 [@mlw:proxy_symbol] [@introduced]  = (5 : int) in (
        ( () (* Translation of an unrolled Ada loop from main.adb:47 *)
        ;
        [#"main.adb" 47 0 0] try
         ( [#"main.adb" 47 0 0] begin ensures {true} let _ = (let _  = Main__count_islands__count.count.int__content in (
          ()))
          in () end ;
         (let temp___loop_entry_271  = [#"main.adb" 47 0 0] (val _f : int
         ensures {[#"main.adb" 47 0 0] (result = Main__count_islands__count.count.int__content)} 
         in _f) in (
          ( [#"main.adb" 47 0 0] begin ensures {true} let _ = (let _  = Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content in (
           ()))
           in () end ;
          (let temp___loop_entry_270  = [#"main.adb" 47 0 0] (val _f : Array__Int_Int__Bool.map
          ensures {[#"main.adb" 47 0 0] (result = Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)} 
          in _f) in (
           ( () (* Unrolling of the loop statements of loop main.adb:47 *)
           ;
           [#"main.adb" 47 0 0] (Main__count_islands__L_2__j.j.int__content <- ( (1 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (2 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (3 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (4 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (5 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) ) )))
           )))
          )
        with
         Main__count_islands__L_2.L_2 -> ()
        end )))
       ))
       ) );
        (Main__count_islands__L_1__i.i.int__content <- ( (3 : int) ));
       ();
       ( [@GP_Sloc:main.adb:47:27] ([#"main.adb" 47 0 0] (let temp___268 [@mlw:proxy_symbol] [@introduced]  = (1 : int) in (
       (let temp___269 [@mlw:proxy_symbol] [@introduced]  = (5 : int) in (
        ( () (* Translation of an unrolled Ada loop from main.adb:47 *)
        ;
        [#"main.adb" 47 0 0] try
         ( [#"main.adb" 47 0 0] begin ensures {true} let _ = (let _  = Main__count_islands__count.count.int__content in (
          ()))
          in () end ;
         (let temp___loop_entry_271  = [#"main.adb" 47 0 0] (val _f : int
         ensures {[#"main.adb" 47 0 0] (result = Main__count_islands__count.count.int__content)} 
         in _f) in (
          ( [#"main.adb" 47 0 0] begin ensures {true} let _ = (let _  = Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content in (
           ()))
           in () end ;
          (let temp___loop_entry_270  = [#"main.adb" 47 0 0] (val _f : Array__Int_Int__Bool.map
          ensures {[#"main.adb" 47 0 0] (result = Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)} 
          in _f) in (
           ( () (* Unrolling of the loop statements of loop main.adb:47 *)
           ;
           [#"main.adb" 47 0 0] (Main__count_islands__L_2__j.j.int__content <- ( (1 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (2 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (3 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (4 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (5 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) ) )))
           )))
          )
        with
         Main__count_islands__L_2.L_2 -> ()
        end )))
       ))
       ) );
        (Main__count_islands__L_1__i.i.int__content <- ( (4 : int) ));
       ();
       ( [@GP_Sloc:main.adb:47:27] ([#"main.adb" 47 0 0] (let temp___268 [@mlw:proxy_symbol] [@introduced]  = (1 : int) in (
       (let temp___269 [@mlw:proxy_symbol] [@introduced]  = (5 : int) in (
        ( () (* Translation of an unrolled Ada loop from main.adb:47 *)
        ;
        [#"main.adb" 47 0 0] try
         ( [#"main.adb" 47 0 0] begin ensures {true} let _ = (let _  = Main__count_islands__count.count.int__content in (
          ()))
          in () end ;
         (let temp___loop_entry_271  = [#"main.adb" 47 0 0] (val _f : int
         ensures {[#"main.adb" 47 0 0] (result = Main__count_islands__count.count.int__content)} 
         in _f) in (
          ( [#"main.adb" 47 0 0] begin ensures {true} let _ = (let _  = Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content in (
           ()))
           in () end ;
          (let temp___loop_entry_270  = [#"main.adb" 47 0 0] (val _f : Array__Int_Int__Bool.map
          ensures {[#"main.adb" 47 0 0] (result = Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)} 
          in _f) in (
           ( () (* Unrolling of the loop statements of loop main.adb:47 *)
           ;
           [#"main.adb" 47 0 0] (Main__count_islands__L_2__j.j.int__content <- ( (1 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (2 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (3 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (4 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Main__count_islands__L_2__j.j.int__content <- ( (5 : int) ));
           ();
           ( [@GP_Sloc:main.adb:48:13] ([#"main.adb" 48 0 0] (if (( ([#"main.adb" 48 0 0] [#"main.adb" 48 0 0] (([@branch_id=2634] Main.spark__branch).bool__content <- ( ( ((Main__int_needed__rep.to_rep((Array__Int_Int__Main__int_needed.get(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2634] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:main.adb:50:16] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:64] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:33] ([#"main.adb" 50 0 0] ()) );
            ( [@GP_Sloc:main.adb:50:30] ([#"main.adb" 50 0 0] [#"main.adb" 50 0 0] (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Main__visit_islands___axiom.visit_islands(Main__count_islands__map_array.map_array) (Main__count_islands__L_1__i.i.int__content) (Main__count_islands__L_2__j.j.int__content) (Main__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) ))) );
            ( [@GP_Sloc:main.adb:51:16] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:25] ([#"main.adb" 51 0 0] ()) );
            ( [@GP_Sloc:main.adb:51:22] ([#"main.adb" 51 0 0] [#"main.adb" 51 0 0] (Main__count_islands__count.count.int__content <- ( ([#"main.adb" 51 0 0] ( [@GP_Sloc:main.adb:51:31] [@GP_Id:11] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ main.adb:51:31:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Main__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) ) )))
           )))
          )
        with
         Main__count_islands__L_2.L_2 -> ()
        end )))
       ))
       ) ) )))
       )))
      )
    with
     Main__count_islands__L_1.L_1 -> ()
    end )))
   ))
   ) );
   ( [@GP_Sloc:main.adb:55:14] ([#"main.adb" 55 0 0] ()) );
   ( [@GP_Sloc:main.adb:55:7] ([#"main.adb" 55 0 0] ( [#"main.adb" 55 0 0] (main__count_islands__result.int__content <- ( Main__count_islands__count.count.int__content ));
   [#"main.adb" 55 0 0] raise Return__exc )) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _  = True in (
   ()))
   in () end ;
  main__count_islands__result.int__content )
end
