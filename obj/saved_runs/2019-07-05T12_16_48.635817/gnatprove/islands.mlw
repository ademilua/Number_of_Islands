(* Module for defining the constant "n" defined at islands.ads:5, created in Gnat2Why.Decls.Translate_Constant *)
module Islands__n
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant n [#"islands.ads" 5 0 0][@model_trace:2597] [@name:N] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the value of constant "n" defined at islands.ads:5, created in Gnat2Why.Decls.Translate_Constant_Value *)
module Islands__n___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Islands__n as Islands__n

 axiom n__def_axiom :
  ((Islands__n.n ) = (4 : int))

end

(* Module for defining the constant "m" defined at islands.ads:6, created in Gnat2Why.Decls.Translate_Constant *)
module Islands__m
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant m [#"islands.ads" 6 0 0][@model_trace:2607] [@name:M] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the value of constant "m" defined at islands.ads:6, created in Gnat2Why.Decls.Translate_Constant_Value *)
module Islands__m___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Islands__m as Islands__m

 axiom m__def_axiom :
  ((Islands__m.m ) = (5 : int))

end

(* Module for defining a ref holding the value of variable "water" defined at islands.ads:13, created in Gnat2Why.Decls.Translate_Variable *)
module Islands__water
 use        "_gnatprove_standard".Main
 use        "int".Int

 val water [#"islands.ads" 13 0 0][@model_projected] [@name:Water] [@model_trace:2656]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "land" defined at islands.ads:14, created in Gnat2Why.Decls.Translate_Variable *)
module Islands__land
 use        "_gnatprove_standard".Main
 use        "int".Int

 val land [#"islands.ads" 14 0 0][@model_projected] [@model_trace:2666] [@name:Land]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for axiomatizing type "int_needed" defined at islands.ads:11, created in Gnat2Why.Types.Translate_Type *)
module Islands__int_needed
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type int_needed =
  < range 0 1 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (1 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = int_needed, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type int_needed__ref =
  { mutable int_needed__content : int_needed }
 
 function int_needed__ref_int_needed__content__projection 
   (a : int_needed__ref) : int_needed =
  a.int_needed__content
 
 meta "model_projection" function int_needed__ref_int_needed__content__projection
 
 meta "inline:no" function int_needed__ref_int_needed__content__projection
 
 val int_needed__havoc 
   (x : int_needed__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "int_needed" defined at islands.ads:11, created in Gnat2Why.Types.Translate_Type *)
module Islands__int_needed__rep
 use        Islands__int_needed as Islands__int_needed
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Islands__int_needed.int_needed) : int =
  (Islands__int_needed.int_needed'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Islands__int_needed.int_needed, 
 predicate in_range = Islands__int_needed.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing the array theory associated to type "TmapB" defined at islands.ads:16, created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int_Int__Islands__int_needed
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Islands__int_needed as Islands__int_needed
 use        Islands__int_needed__rep as Islands__int_needed__rep

 function index_I1_one 
   : int =
  (1 : int)
 
 function index_I2_one 
   : int =
  (1 : int)
 
 type component_type =
  Islands__int_needed.int_needed
 
 clone export "_gnatprove_standard".Array__2 with axiom .,
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type I2.t = int, 
 predicate I2.le = Int.(<=), 
 predicate I2.lt = Int.(<), 
 predicate I2.gt = Int.(>), 
 function I2.add = Int.(+), 
 function I2.sub = Int.(-), 
 function I2.one = index_I2_one, 
 type component_type = component_type
 
 function bool_eq 
   (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) : bool =
  ( ( (if ((a__first <= a__last)) then (
   ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
   (b__first > b__last))) /\ (if ((a__first_2 <= a__last_2)) then (
   ( (b__first_2 <= b__last_2) /\ ((a__last_2 - a__first_2) = (b__last_2 - b__first_2)) )) else (
   (b__first_2 > b__last_2))) ) /\ (forall temp___idx_154   temp___idx_155   : int.
   (if (( ( (a__first <= temp___idx_154) /\ (temp___idx_154 <= a__last) ) /\ ( (a__first_2 <= temp___idx_155) /\ (temp___idx_155 <= a__last_2) ) )) then (
    ((Islands__int_needed__rep.to_rep (get a temp___idx_154 temp___idx_155)) = (Islands__int_needed__rep.to_rep (get b ((b__first - a__first) + temp___idx_154) ((b__first_2 - a__first_2) + temp___idx_155))))) else true)) )
 val bool_eq 
   (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) : bool
  ensures { result = bool_eq (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) }
 
 axiom bool_eq_rev :
  (forall a   b   : map.
  (forall a__first   a__last   a__first_2   a__last_2   b__first   b__last   b__first_2   b__last_2   : int.
   ( ((bool_eq b b__first b__last b__first_2 b__last_2 a a__first a__last a__first_2 a__last_2) = True) -> ( ( (if ((a__first <= a__last)) then (
    ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
    (b__first > b__last))) /\ (if ((a__first_2 <= a__last_2)) then (
    ( (b__first_2 <= b__last_2) /\ ((a__last_2 - a__first_2) = (b__last_2 - b__first_2)) )) else (
    (b__first_2 > b__last_2))) ) /\ (forall temp___idx_154   temp___idx_155   : int.
    (if (( ( (a__first <= temp___idx_154) /\ (temp___idx_154 <= a__last) ) /\ ( (a__first_2 <= temp___idx_155) /\ (temp___idx_155 <= a__last_2) ) )) then (
     ((Islands__int_needed__rep.to_rep (get a temp___idx_154 temp___idx_155)) = (Islands__int_needed__rep.to_rep (get b ((b__first - a__first) + temp___idx_154) ((b__first_2 - a__first_2) + temp___idx_155))))) else true)) ) )))

end

(* Module for axiomatizing the array theory associated to type "TvisitedB" defined at islands.ads:17, created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int_Int__Bool
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 function index_I1_one 
   : int =
  (1 : int)
 
 function index_I2_one 
   : int =
  (1 : int)
 
 type component_type =
  bool
 
 clone export "_gnatprove_standard".Array__2 with axiom .,
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type I2.t = int, 
 predicate I2.le = Int.(<=), 
 predicate I2.lt = Int.(<), 
 predicate I2.gt = Int.(>), 
 function I2.add = Int.(+), 
 function I2.sub = Int.(-), 
 function I2.one = index_I2_one, 
 type component_type = component_type
 
 function bool_eq 
   (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) : bool =
  ( ( (if ((a__first <= a__last)) then (
   ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
   (b__first > b__last))) /\ (if ((a__first_2 <= a__last_2)) then (
   ( (b__first_2 <= b__last_2) /\ ((a__last_2 - a__first_2) = (b__last_2 - b__first_2)) )) else (
   (b__first_2 > b__last_2))) ) /\ (forall temp___idx_156   temp___idx_157   : int.
   (if (( ( (a__first <= temp___idx_156) /\ (temp___idx_156 <= a__last) ) /\ ( (a__first_2 <= temp___idx_157) /\ (temp___idx_157 <= a__last_2) ) )) then (
    ((get a temp___idx_156 temp___idx_157) = (get b ((b__first - a__first) + temp___idx_156) ((b__first_2 - a__first_2) + temp___idx_157)))) else true)) )
 val bool_eq 
   (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) : bool
  ensures { result = bool_eq (a : map) (a__first : int) (a__last : int) (a__first_2 : int) (a__last_2 : int) (b : map) (b__first : int) (b__last : int) (b__first_2 : int) (b__last_2 : int) }
 
 axiom bool_eq_rev :
  (forall a   b   : map.
  (forall a__first   a__last   a__first_2   a__last_2   b__first   b__last   b__first_2   b__last_2   : int.
   ( ((bool_eq b b__first b__last b__first_2 b__last_2 a a__first a__last a__first_2 a__last_2) = True) -> ( ( (if ((a__first <= a__last)) then (
    ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
    (b__first > b__last))) /\ (if ((a__first_2 <= a__last_2)) then (
    ( (b__first_2 <= b__last_2) /\ ((a__last_2 - a__first_2) = (b__last_2 - b__first_2)) )) else (
    (b__first_2 > b__last_2))) ) /\ (forall temp___idx_156   temp___idx_157   : int.
    (if (( ( (a__first <= temp___idx_156) /\ (temp___idx_156 <= a__last) ) /\ ( (a__first_2 <= temp___idx_157) /\ (temp___idx_157 <= a__last_2) ) )) then (
     ((get a temp___idx_156 temp___idx_157) = (get b ((b__first - a__first) + temp___idx_156) ((b__first_2 - a__first_2) + temp___idx_157)))) else true)) ) )))

end

(* Module for possibly declaring a logic function for "visit_islands" defined at islands.ads:25, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Islands__visit_islands
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val function visit_islands 
   (map_array : Array__Int_Int__Islands__int_needed.map) (i : int) (j : int) (visited_array : Array__Int_Int__Bool.map) (islands__water : int) (islands__land : int) : Array__Int_Int__Bool.map
 
 val predicate visit_islands__function_guard 
   (temp___result_158 : Array__Int_Int__Bool.map) (map_array : Array__Int_Int__Islands__int_needed.map) (i : int) (j : int) (visited_array : Array__Int_Int__Bool.map) (islands__water : int) (islands__land : int)

end

(* Module giving axioms for type "visited" defined at islands.ads:17, created in Gnat2Why.Types.Generate_Type_Completion *)
module Islands__visited___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 predicate dynamic_invariant [@inline] 
   (temp___expr_197 : Array__Int_Int__Bool.map) (temp___is_init_193 : bool) (temp___skip_constant_194 : bool) (temp___do_toplevel_195 : bool) (temp___do_typ_inv_196 : bool) =
  true
 val dynamic_invariant [@inline] 
   (temp___expr_197 : Array__Int_Int__Bool.map) (temp___is_init_193 : bool) (temp___skip_constant_194 : bool) (temp___do_toplevel_195 : bool) (temp___do_typ_inv_196 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_197 : Array__Int_Int__Bool.map) (temp___is_init_193 : bool) (temp___skip_constant_194 : bool) (temp___do_toplevel_195 : bool) (temp___do_typ_inv_196 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_200 : Array__Int_Int__Bool.map) (temp___skip_top_level_201 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_200 : Array__Int_Int__Bool.map) (temp___skip_top_level_201 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_200 : Array__Int_Int__Bool.map) (temp___skip_top_level_201 : bool) }

end

(* Module for declaring a program function (and possibly an axiom) for "visit_islands" defined at islands.ads:25, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Islands__visit_islands___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Islands__water as Islands__water
 use        Islands__land as Islands__land
 use        Islands__visit_islands as Islands__visit_islands
 use        Islands__int_needed as Islands__int_needed
 use        Islands__int_needed__rep as Islands__int_needed__rep
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed
 use        Islands__visited___axiom as Islands__visited___axiom
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val visit_islands 
   (map_array : Array__Int_Int__Islands__int_needed.map) (i : int) (j : int) (visited_array : Array__Int_Int__Bool.map) : Array__Int_Int__Bool.map
  requires {  ( [@GP_Pretty_Ada:2857] ((Islands__int_needed__rep.to_rep (Array__Int_Int__Islands__int_needed.get map_array i j)) > (3 : int)) ) }
  ensures {  ( ( (result = (Islands__visit_islands.visit_islands map_array i j visited_array Islands__water.water.int__content Islands__land.land.int__content)) /\ (Islands__visit_islands.visit_islands__function_guard result map_array i j visited_array Islands__water.water.int__content Islands__land.land.int__content) )/\(Islands__visited___axiom.dynamic_invariant result True False True True) ) }
  reads {Islands__water.water, Islands__land.land}

end

(* Module for axiomatizing type "integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type integer =
  < range -2147483648 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (( -2147483648) : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type integer__ref =
  { mutable integer__content : integer }
 
 function integer__ref_integer__content__projection 
   (a : integer__ref) : integer =
  a.integer__content
 
 meta "model_projection" function integer__ref_integer__content__projection
 
 meta "inline:no" function integer__ref_integer__content__projection
 
 val integer__havoc 
   (x : integer__ref) : unit
  writes {x}

end

(* Module giving axioms for type "integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer as Standard__integer

 predicate dynamic_invariant [@inline] 
   (temp___expr_18 : int) (temp___is_init_14 : bool) (temp___skip_constant_15 : bool) (temp___do_toplevel_16 : bool) (temp___do_typ_inv_17 : bool) =
  (if (( temp___is_init_14 \/ (Standard__integer.first <= Standard__integer.last) )) then (
   (Standard__integer.dynamic_property Standard__integer.first Standard__integer.last temp___expr_18)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_18 : int) (temp___is_init_14 : bool) (temp___skip_constant_15 : bool) (temp___do_toplevel_16 : bool) (temp___do_typ_inv_17 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_18 : int) (temp___is_init_14 : bool) (temp___skip_constant_15 : bool) (temp___do_toplevel_16 : bool) (temp___do_typ_inv_17 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_19 : int) (temp___skip_top_level_20 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_19 : int) (temp___skip_top_level_20 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_19 : int) (temp___skip_top_level_20 : bool) }

end

(* Module for possibly declaring a logic function for "count_islands" defined at islands.ads:31, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Islands__count_islands
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed

 val function count_islands 
   (map_array : Array__Int_Int__Islands__int_needed.map) (islands__water : int) (islands__land : int) : int
 
 val predicate count_islands__function_guard 
   (temp___result_159 : int) (map_array : Array__Int_Int__Islands__int_needed.map) (islands__water : int) (islands__land : int)

end

(* Module for declaring a program function (and possibly an axiom) for "count_islands" defined at islands.ads:31, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Islands__count_islands___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer as Standard__integer
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Islands__water as Islands__water
 use        Islands__land as Islands__land
 use        Islands__count_islands as Islands__count_islands
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed

 val count_islands 
   (map_array : Array__Int_Int__Islands__int_needed.map) : int
  requires {  ( [@GP_Pretty_Ada:2876] true ) }
  ensures {  ( ( (result = (Islands__count_islands.count_islands map_array Islands__water.water.int__content Islands__land.land.int__content)) /\ (Islands__count_islands.count_islands__function_guard result map_array Islands__water.water.int__content Islands__land.land.int__content) )/\( (Standard__integer___axiom.dynamic_invariant result True False True True) /\ ( [@GP_Pretty_Ada:2889] (result < (20 : int)) ) ) ) }
  reads {Islands__water.water, Islands__land.land}
 
 axiom count_islands__post_axiom :
  (forall map_array   : Array__Int_Int__Islands__int_needed.map.
  (forall islands__water   islands__land   : int [(Islands__count_islands.count_islands map_array islands__water islands__land)].
   (let result  = (Islands__count_islands.count_islands map_array islands__water islands__land) in (
    (Standard__integer.dynamic_property Standard__integer.first Standard__integer.last result)))
  ))

end

(* Module giving axioms for type "int_needed" defined at islands.ads:11, created in Gnat2Why.Types.Generate_Type_Completion *)
module Islands__int_needed___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Islands__int_needed as Islands__int_needed

 predicate dynamic_invariant [@inline] 
   (temp___expr_178 : int) (temp___is_init_174 : bool) (temp___skip_constant_175 : bool) (temp___do_toplevel_176 : bool) (temp___do_typ_inv_177 : bool) =
  (if (( temp___is_init_174 \/ (Islands__int_needed.first <= Islands__int_needed.last) )) then (
   (Islands__int_needed.dynamic_property Islands__int_needed.first Islands__int_needed.last temp___expr_178)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_178 : int) (temp___is_init_174 : bool) (temp___skip_constant_175 : bool) (temp___do_toplevel_176 : bool) (temp___do_typ_inv_177 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_178 : int) (temp___is_init_174 : bool) (temp___skip_constant_175 : bool) (temp___do_toplevel_176 : bool) (temp___do_typ_inv_177 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_179 : int) (temp___skip_top_level_180 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_179 : int) (temp___skip_top_level_180 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_179 : int) (temp___skip_top_level_180 : bool) }

end

(* Module giving an empty axiom for the entity "water" defined at islands.ads:13, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__water___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "land" defined at islands.ads:14, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__land___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for checking absence of run-time errors and package initial condition on package elaboration of "islands" defined at islands.ads:1, created in Gnat2Why.Subprograms.Generate_VCs_For_Package_Elaboration *)
module Islands__package_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Islands__n as Islands__n
 use        Islands__m as Islands__m
 use        Islands__water as Islands__water
 use        Islands__land as Islands__land
 use        Islands__int_needed___axiom as Islands__int_needed___axiom
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Islands__n___axiom as Islands__n___axiom
 use        Islands__m___axiom as Islands__m___axiom
 use        Islands__int_needed___axiom as Islands__int_needed___axiom
 use        Islands__water___axiom as Islands__water___axiom
 use        Islands__land___axiom as Islands__land___axiom

 let def [#"islands.ads" 1 0 0][@GP_Subp:islands.ads:1] 
   (__void_param : unit)
  requires { [#"islands.ads" 1 0 0] true }
   = [@vc:divergent]
  ( ();
  ([#"islands.ads" 2 0 0] ());
  ([#"islands.ads" 5 0 0] ( [#"islands.ads" 5 0 0] begin ensures {true} let _ = (let _  = (4 : int) in (
   ()))
   in () end ;
  [#"islands.ads" 5 0 0] assume { [#"islands.ads" 5 0 0] (Standard__integer___axiom.dynamic_invariant Islands__n.n True False True True) } ));
  ([#"islands.ads" 6 0 0] ( [#"islands.ads" 6 0 0] begin ensures {true} let _ = (let _  = (5 : int) in (
   ()))
   in () end ;
  [#"islands.ads" 6 0 0] assume { [#"islands.ads" 6 0 0] (Standard__integer___axiom.dynamic_invariant Islands__m.m True False True True) } ));
  ([#"islands.ads" 7 0 0] ());
  ([#"islands.ads" 9 0 0] ());
  ([#"islands.ads" 11 0 0] ());
  ([#"islands.ads" 13 0 0] ());
  ([#"islands.ads" 13 0 0] ());
  ([#"islands.ads" 13 0 0] ( [#"islands.ads" 13 0 0] (Islands__water.water.int__content <- ( (0 : int) ));
  [#"islands.ads" 13 0 0] assume { [#"islands.ads" 13 0 0] (Islands__int_needed___axiom.dynamic_invariant Islands__water.water.int__content True False True True) } ));
  ([#"islands.ads" 14 0 0] ( [#"islands.ads" 14 0 0] (Islands__land.land.int__content <- ( (1 : int) ));
  [#"islands.ads" 14 0 0] assume { [#"islands.ads" 14 0 0] (Islands__int_needed___axiom.dynamic_invariant Islands__land.land.int__content True False True True) } ));
  ([#"islands.ads" 16 0 0] ());
  ([#"islands.ads" 17 0 0] ());
  ([#"islands.ads" 25 0 0] ());
  ([#"islands.ads" 28 0 0] ());
  ([#"islands.ads" 27 0 0] ());
  ([#"islands.ads" 31 0 0] ());
  ([#"islands.ads" 33 0 0] ());
  ([#"islands.ads" 32 0 0] ());
  ([#"islands.ads" 32 0 0] ());
  ([#"islands.ads" 32 0 0] ());
  ([#"islands.ads" 32 0 0] ());
  ([#"islands.ads" 32 0 0] ());
  ([#"islands.ads" 32 0 0] ());
  ([#"islands.ads" 32 0 0] ());
  ();
  ([#"islands.adb" 2 0 0] ());
  ([#"islands.adb" 5 0 0] ());
  ([#"islands.adb" 27 0 0] ());
  ();
  ( [@GP_Sloc:islands.adb:47:1] ([#"islands.adb" 47 0 0] ()) ) )
end

(* Module for defining the constant "map_array" defined at islands.ads:26, created in Gnat2Why.Decls.Translate_Constant *)
module Islands__visit_islands__map_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed

 val constant map_array [#"islands.ads" 26 0 0][@model_trace:2711] [@model_projected] [@name:Map_Array] 
   : Array__Int_Int__Islands__int_needed.map

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the constant "i" defined at islands.ads:26, created in Gnat2Why.Decls.Translate_Constant *)
module Islands__visit_islands__i
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant i [#"islands.ads" 26 0 0][@name:i] [@model_trace:2720] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the constant "j" defined at islands.ads:26, created in Gnat2Why.Decls.Translate_Constant *)
module Islands__visit_islands__j
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant j [#"islands.ads" 26 0 0][@model_trace:2729] [@name:j] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the constant "visited_array" defined at islands.ads:26, created in Gnat2Why.Decls.Translate_Constant *)
module Islands__visit_islands__visited_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val constant visited_array [#"islands.ads" 26 0 0][@model_projected] [@name:Visited_Array] [@model_trace:2738] 
   : Array__Int_Int__Bool.map

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "vis_array" defined at islands.adb:8, created in Gnat2Why.Decls.Translate_Variable *)
module Islands__visit_islands__vis_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val vis_array [#"islands.adb" 8 0 0][@name:Vis_Array] [@model_trace:2354] [@model_projected]  : Array__Int_Int__Bool.map__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for axiomatizing type "n_range" defined at islands.ads:7, created in Gnat2Why.Types.Translate_Type *)
module Islands__n_range
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type n_range =
  < range 1 4 >
 
 val constant first 
   : int
  ensures { result =  (1 : int) }
 
 val constant last 
   : int
  ensures { result =  (4 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = n_range, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type n_range__ref =
  { mutable n_range__content : n_range }
 
 function n_range__ref_n_range__content__projection 
   (a : n_range__ref) : n_range =
  a.n_range__content
 
 meta "model_projection" function n_range__ref_n_range__content__projection
 
 meta "inline:no" function n_range__ref_n_range__content__projection
 
 val n_range__havoc 
   (x : n_range__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "m_range" defined at islands.ads:9, created in Gnat2Why.Types.Translate_Type *)
module Islands__m_range
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type m_range =
  < range 1 5 >
 
 val constant first 
   : int
  ensures { result =  (1 : int) }
 
 val constant last 
   : int
  ensures { result =  (5 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = m_range, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type m_range__ref =
  { mutable m_range__content : m_range }
 
 function m_range__ref_m_range__content__projection 
   (a : m_range__ref) : m_range =
  a.m_range__content
 
 meta "model_projection" function m_range__ref_m_range__content__projection
 
 meta "inline:no" function m_range__ref_m_range__content__projection
 
 val m_range__havoc 
   (x : m_range__ref) : unit
  writes {x}

end

(* Module giving axioms for type "map" defined at islands.ads:16, created in Gnat2Why.Types.Generate_Type_Completion *)
module Islands__map___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed

 predicate dynamic_invariant [@inline] 
   (temp___expr_185 : Array__Int_Int__Islands__int_needed.map) (temp___is_init_181 : bool) (temp___skip_constant_182 : bool) (temp___do_toplevel_183 : bool) (temp___do_typ_inv_184 : bool) =
  true
 val dynamic_invariant [@inline] 
   (temp___expr_185 : Array__Int_Int__Islands__int_needed.map) (temp___is_init_181 : bool) (temp___skip_constant_182 : bool) (temp___do_toplevel_183 : bool) (temp___do_typ_inv_184 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_185 : Array__Int_Int__Islands__int_needed.map) (temp___is_init_181 : bool) (temp___skip_constant_182 : bool) (temp___do_toplevel_183 : bool) (temp___do_typ_inv_184 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_188 : Array__Int_Int__Islands__int_needed.map) (temp___skip_top_level_189 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_188 : Array__Int_Int__Islands__int_needed.map) (temp___skip_top_level_189 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_188 : Array__Int_Int__Islands__int_needed.map) (temp___skip_top_level_189 : bool) }

end

(* Module giving an empty axiom for the entity "vis_array" defined at islands.adb:8, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__visit_islands__vis_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "n_range" defined at islands.ads:7, created in Gnat2Why.Types.Generate_Type_Completion *)
module Islands__n_range___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Islands__n_range as Islands__n_range

 predicate dynamic_invariant [@inline] 
   (temp___expr_164 : int) (temp___is_init_160 : bool) (temp___skip_constant_161 : bool) (temp___do_toplevel_162 : bool) (temp___do_typ_inv_163 : bool) =
  (if (( temp___is_init_160 \/ (Islands__n_range.first <= Islands__n_range.last) )) then (
   (Islands__n_range.dynamic_property Islands__n_range.first Islands__n_range.last temp___expr_164)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_164 : int) (temp___is_init_160 : bool) (temp___skip_constant_161 : bool) (temp___do_toplevel_162 : bool) (temp___do_typ_inv_163 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_164 : int) (temp___is_init_160 : bool) (temp___skip_constant_161 : bool) (temp___do_toplevel_162 : bool) (temp___do_typ_inv_163 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_165 : int) (temp___skip_top_level_166 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_165 : int) (temp___skip_top_level_166 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_165 : int) (temp___skip_top_level_166 : bool) }

end

(* Module giving axioms for type "m_range" defined at islands.ads:9, created in Gnat2Why.Types.Generate_Type_Completion *)
module Islands__m_range___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Islands__m_range as Islands__m_range

 predicate dynamic_invariant [@inline] 
   (temp___expr_171 : int) (temp___is_init_167 : bool) (temp___skip_constant_168 : bool) (temp___do_toplevel_169 : bool) (temp___do_typ_inv_170 : bool) =
  (if (( temp___is_init_167 \/ (Islands__m_range.first <= Islands__m_range.last) )) then (
   (Islands__m_range.dynamic_property Islands__m_range.first Islands__m_range.last temp___expr_171)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_171 : int) (temp___is_init_167 : bool) (temp___skip_constant_168 : bool) (temp___do_toplevel_169 : bool) (temp___do_typ_inv_170 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_171 : int) (temp___is_init_167 : bool) (temp___skip_constant_168 : bool) (temp___do_toplevel_169 : bool) (temp___do_typ_inv_170 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_172 : int) (temp___skip_top_level_173 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_172 : int) (temp___skip_top_level_173 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_172 : int) (temp___skip_top_level_173 : bool) }

end

(* Module giving an empty axiom for the entity "map_array" defined at islands.ads:26, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__visit_islands__map_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "i" defined at islands.ads:26, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__visit_islands__i___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "j" defined at islands.ads:26, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__visit_islands__j___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "visited_array" defined at islands.ads:26, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__visit_islands__visited_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for checking contracts and absence of run-time errors in subprogram "visit_islands" defined at islands.ads:25, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Islands__visit_islands__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Boolean as Boolean
 use        Standard__integer as Standard__integer
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Islands__water as Islands__water
 use        Islands__land as Islands__land
 use        Islands__visit_islands__map_array as Islands__visit_islands__map_array
 use        Islands__visit_islands__i as Islands__visit_islands__i
 use        Islands__visit_islands__j as Islands__visit_islands__j
 use        Islands__visit_islands__visited_array as Islands__visit_islands__visited_array
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Islands__visit_islands___axiom as Islands__visit_islands___axiom
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Islands__visit_islands__vis_array as Islands__visit_islands__vis_array
 use        Islands__n_range as Islands__n_range
 use        Islands__m_range as Islands__m_range
 use        Islands__int_needed as Islands__int_needed
 use        Islands__int_needed___axiom as Islands__int_needed___axiom
 use        Islands__int_needed__rep as Islands__int_needed__rep
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed
 use        Islands__map___axiom as Islands__map___axiom
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Islands__visited___axiom as Islands__visited___axiom
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Islands__visit_islands__vis_array___axiom as Islands__visit_islands__vis_array___axiom
 use        Islands__n_range___axiom as Islands__n_range___axiom
 use        Islands__m_range___axiom as Islands__m_range___axiom
 use        Islands__int_needed___axiom as Islands__int_needed___axiom
 use        Islands__water___axiom as Islands__water___axiom
 use        Islands__land___axiom as Islands__land___axiom
 use        Islands__map___axiom as Islands__map___axiom
 use        Islands__visited___axiom as Islands__visited___axiom
 use        Islands__visit_islands___axiom as Islands__visit_islands___axiom
 use        Islands__visit_islands__map_array___axiom as Islands__visit_islands__map_array___axiom
 use        Islands__visit_islands__i___axiom as Islands__visit_islands__i___axiom
 use        Islands__visit_islands__j___axiom as Islands__visit_islands__j___axiom
 use        Islands__visit_islands__visited_array___axiom as Islands__visit_islands__visited_array___axiom

 val islands__visit_islands__result [@model_projected] [@name:Visit_Islands] [@model_trace:2704@result]  : Array__Int_Int__Bool.map__ref 
 
 let def [#"islands.ads" 25 0 0][@GP_Subp:islands.ads:25] 
   (__void_param : unit)
  requires { [#"islands.ads" 25 0 0] true }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram islands.ads:25 *)
  ;
  [#"islands.ads" 25 0 0] assume { [#"islands.ads" 25 0 0] (Islands__int_needed___axiom.dynamic_invariant Islands__water.water.int__content True False True True) };
  [#"islands.ads" 25 0 0] assume { [#"islands.ads" 25 0 0] (Islands__int_needed___axiom.dynamic_invariant Islands__land.land.int__content True False True True) };
  [#"islands.ads" 25 0 0] assume { [#"islands.ads" 25 0 0] (Islands__map___axiom.dynamic_invariant Islands__visit_islands__map_array.map_array True False True True) };
  [#"islands.ads" 25 0 0] assume { [#"islands.ads" 25 0 0] (Standard__integer___axiom.dynamic_invariant Islands__visit_islands__i.i True False True True) };
  [#"islands.ads" 25 0 0] assume { [#"islands.ads" 25 0 0] (Standard__integer___axiom.dynamic_invariant Islands__visit_islands__j.j True False True True) };
  [#"islands.ads" 25 0 0] assume { [#"islands.ads" 25 0 0] (Islands__visited___axiom.dynamic_invariant Islands__visit_islands__visited_array.visited_array True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram islands.ads:25 *)
  ;
  () (* Check for RTE in the Pre of the subprogram islands.ads:25 *)
  ;
  [#"islands.ads" 25 0 0] begin ensures {true} let _ = (let _  = ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__visit_islands__map_array.map_array) (( [#"islands.ads" 25 0 0] assert { [#"islands.ads" 25 0 0] ([#"islands.ads" 28 0 0] ( [@comment:                          Pre => Map_Array(i,j)> 3;                                            ^ islands.ads:28:44:VC_INDEX_CHECK] [@GP_Id:14] [@vc:annotation] [@GP_Sloc:islands.ads:28:44] [@GP_Reason:VC_INDEX_CHECK] [@GP_Shape:pragargs__cmp__ixdcomp] ( (Islands__n_range.first <= Islands__visit_islands__i.i) /\ (Islands__visit_islands__i.i <= Islands__n_range.last) ) )) };
  Islands__visit_islands__i.i )) ((  assert {  ([#"islands.ads" 28 0 0] ( [@GP_Id:15] [@vc:annotation] [@GP_Sloc:islands.ads:28:46] [@GP_Reason:VC_INDEX_CHECK] [@comment:                          Pre => Map_Array(i,j)> 3;                                              ^ islands.ads:28:46:VC_INDEX_CHECK] [@GP_Shape:pragargs__cmp__ixdcomp] ( (Islands__m_range.first <= Islands__visit_islands__j.j) /\ (Islands__visit_islands__j.j <= Islands__m_range.last) ) )) };
  Islands__visit_islands__j.j ))))) > (3 : int)) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram islands.ads:25 *)
  ;
   assume {  ( [@GP_Pretty_Ada:2857] ((Islands__int_needed__rep.to_rep (Array__Int_Int__Islands__int_needed.get Islands__visit_islands__map_array.map_array Islands__visit_islands__i.i Islands__visit_islands__j.j)) > (3 : int)) ) };
   try
   ( ();
   ([#"islands.adb" 8 0 0] ( [#"islands.adb" 8 0 0] (Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( Islands__visit_islands__visited_array.visited_array ));
   [#"islands.adb" 8 0 0] assume { [#"islands.adb" 8 0 0] (Islands__visited___axiom.dynamic_invariant Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content True False True True) } ));
   ();
   ( [@GP_Sloc:islands.adb:13:7] ([#"islands.adb" 13 0 0] (if (( ([#"islands.adb" 13 0 0] [#"islands.adb" 13 0 0] (([@branch_id=2365] Main.spark__branch).bool__content <- ( ( ( ( ( ( (Islands__visit_islands__i.i < (1 : int)) || (Islands__visit_islands__j.j < (1 : int)) ) || (Islands__visit_islands__i.i > (4 : int)) ) || (Islands__visit_islands__j.j > (5 : int)) ) || ((Boolean.to_int((Array__Int_Int__Bool.get(Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content) (( [#"islands.adb" 13 0 0] assert { [#"islands.adb" 13 0 0] ([#"islands.adb" 13 0 0] ( [@vc:annotation] [@comment:      if i < 1 or else j < 1 or else i > N or else j > M or else Vis_Array(i, j)=True or else Map_Array(i,j)=0 then                                                                            ^ islands.adb:13:76:VC_INDEX_CHECK] [@GP_Sloc:islands.adb:13:76] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:0] [@GP_Shape:if__orelse__orelse__cmp__ixdcomp] ( (Islands__n_range.first <= Islands__visit_islands__i.i) /\ (Islands__visit_islands__i.i <= Islands__n_range.last) ) )) };
   Islands__visit_islands__i.i )) ((  assert {  ([#"islands.adb" 13 0 0] ( [@vc:annotation] [@comment:      if i < 1 or else j < 1 or else i > N or else j > M or else Vis_Array(i, j)=True or else Map_Array(i,j)=0 then                                                                               ^ islands.adb:13:79:VC_INDEX_CHECK] [@GP_Sloc:islands.adb:13:79] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:1] [@GP_Shape:if__orelse__orelse__cmp__ixdcomp] ( (Islands__m_range.first <= Islands__visit_islands__j.j) /\ (Islands__visit_islands__j.j <= Islands__m_range.last) ) )) };
   Islands__visit_islands__j.j ))))) = (Boolean.to_int((Boolean.of_int((1 : int)))))) ) || ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__visit_islands__map_array.map_array) ((  assert {  ([#"islands.adb" 13 0 0] ( [@comment:      if i < 1 or else j < 1 or else i > N or else j > M or else Vis_Array(i, j)=True or else Map_Array(i,j)=0 then                                                                                                         ^ islands.adb:13:105:VC_INDEX_CHECK] [@GP_Sloc:islands.adb:13:105] [@vc:annotation] [@GP_Shape:if__orelse__cmp__ixdcomp] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:2] ( (Islands__n_range.first <= Islands__visit_islands__i.i) /\ (Islands__visit_islands__i.i <= Islands__n_range.last) ) )) };
   Islands__visit_islands__i.i )) ((  assert {  ([#"islands.adb" 13 0 0] ( [@GP_Sloc:islands.adb:13:107] [@vc:annotation] [@GP_Shape:if__orelse__cmp__ixdcomp] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:3] [@comment:      if i < 1 or else j < 1 or else i > N or else j > M or else Vis_Array(i, j)=True or else Map_Array(i,j)=0 then                                                                                                           ^ islands.adb:13:107:VC_INDEX_CHECK] ( (Islands__m_range.first <= Islands__visit_islands__j.j) /\ (Islands__visit_islands__j.j <= Islands__m_range.last) ) )) };
   Islands__visit_islands__j.j ))))) = (0 : int)) ) )));
   ( [@branch_id=2365] Main.spark__branch ).bool__content )) then (
    ( ();
    ( [@GP_Sloc:islands.adb:14:17] ([#"islands.adb" 14 0 0] ()) );
    ( [@GP_Sloc:islands.adb:14:10] ([#"islands.adb" 14 0 0] ( [#"islands.adb" 14 0 0] (islands__visit_islands__result.Array__Int_Int__Bool.map__content <- ( Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content ));
    [#"islands.adb" 14 0 0] raise Return__exc )) ) )) else (
    ()))) );
   ( [@GP_Sloc:islands.adb:17:7] ([#"islands.adb" 17 0 0] ()) );
   ( [@GP_Sloc:islands.adb:17:22] ([#"islands.adb" 17 0 0] [#"islands.adb" 17 0 0] (Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( (Array__Int_Int__Bool.set(Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content) (( [#"islands.adb" 17 0 0] assert { [#"islands.adb" 17 0 0] ([#"islands.adb" 17 0 0] ( [@GP_Shape:vis_array_assign__ixdcomp] [@comment:      Vis_Array(i, j):= True;                 ^ islands.adb:17:17:VC_INDEX_CHECK] [@vc:annotation] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:4] [@GP_Sloc:islands.adb:17:17] ( (Islands__n_range.first <= Islands__visit_islands__i.i) /\ (Islands__visit_islands__i.i <= Islands__n_range.last) ) )) };
   Islands__visit_islands__i.i )) ((  assert {  ([#"islands.adb" 17 0 0] ( [@comment:      Vis_Array(i, j):= True;                    ^ islands.adb:17:20:VC_INDEX_CHECK] [@GP_Shape:vis_array_assign__ixdcomp] [@vc:annotation] [@GP_Sloc:islands.adb:17:20] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:5] ( (Islands__m_range.first <= Islands__visit_islands__j.j) /\ (Islands__visit_islands__j.j <= Islands__m_range.last) ) )) };
   Islands__visit_islands__j.j )) ((Boolean.of_int((1 : int))))) ))) );
   ( [@GP_Sloc:islands.adb:19:7] ([#"islands.adb" 19 0 0] ()) );
   ( [@GP_Sloc:islands.adb:19:56] ([#"islands.adb" 19 0 0] ()) );
   ( [@GP_Sloc:islands.adb:19:20] ([#"islands.adb" 19 0 0] ()) );
   ( [@GP_Sloc:islands.adb:19:17] ([#"islands.adb" 19 0 0] [#"islands.adb" 19 0 0] (Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 19 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Shape:vis_array_assign__call_visit_islands] [@vc:annotation] [@GP_Sloc:islands.adb:19:20] [@comment:      Vis_Array := Visit_Islands(Map_Array,  i + 1, j, Vis_Array);-- recur the buttom                    ^ islands.adb:19:20:VC_PRECONDITION] [@GP_Id:7] (Islands__visit_islands___axiom.visit_islands(Islands__visit_islands__map_array.map_array) (([#"islands.adb" 19 0 0] ( [@GP_Sloc:islands.adb:19:48] [@vc:annotation] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:      Vis_Array := Visit_Islands(Map_Array,  i + 1, j, Vis_Array);-- recur the buttom                                                ^ islands.adb:19:48:VC_OVERFLOW_CHECK] [@GP_Shape:vis_array_assign__call_visit_islands__add] [@GP_Id:6] (Standard__integer.range_check_((Islands__visit_islands__i.i + (1 : int)))) ))) (Islands__visit_islands__j.j) (Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content)) )) ))) );
   ( [@GP_Sloc:islands.adb:20:7] ([#"islands.adb" 20 0 0] ()) );
   ( [@GP_Sloc:islands.adb:20:56] ([#"islands.adb" 20 0 0] ()) );
   ( [@GP_Sloc:islands.adb:20:20] ([#"islands.adb" 20 0 0] ()) );
   ( [@GP_Sloc:islands.adb:20:17] ([#"islands.adb" 20 0 0] [#"islands.adb" 20 0 0] (Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 20 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Shape:vis_array_assign__call_visit_islands] [@vc:annotation] [@comment:      Vis_Array := Visit_Islands(Map_Array,  i - 1, j, Vis_Array);-- recur the top                    ^ islands.adb:20:20:VC_PRECONDITION] [@GP_Sloc:islands.adb:20:20] [@GP_Id:9] (Islands__visit_islands___axiom.visit_islands(Islands__visit_islands__map_array.map_array) (([#"islands.adb" 20 0 0] ( [@vc:annotation] [@GP_Sloc:islands.adb:20:48] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:      Vis_Array := Visit_Islands(Map_Array,  i - 1, j, Vis_Array);-- recur the top                                                ^ islands.adb:20:48:VC_OVERFLOW_CHECK] [@GP_Shape:vis_array_assign__call_visit_islands__sub] [@GP_Id:8] (Standard__integer.range_check_((Islands__visit_islands__i.i - (1 : int)))) ))) (Islands__visit_islands__j.j) (Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content)) )) ))) );
   ( [@GP_Sloc:islands.adb:21:7] ([#"islands.adb" 21 0 0] ()) );
   ( [@GP_Sloc:islands.adb:21:56] ([#"islands.adb" 21 0 0] ()) );
   ( [@GP_Sloc:islands.adb:21:20] ([#"islands.adb" 21 0 0] ()) );
   ( [@GP_Sloc:islands.adb:21:17] ([#"islands.adb" 21 0 0] [#"islands.adb" 21 0 0] (Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 21 0 0] ( [@GP_Id:11] [@GP_Reason:VC_PRECONDITION] [@GP_Sloc:islands.adb:21:20] [@comment:      Vis_Array := Visit_Islands(Map_Array,  i, j + 1, Vis_Array);-- recur the right                    ^ islands.adb:21:20:VC_PRECONDITION] [@GP_Shape:vis_array_assign__call_visit_islands] [@vc:annotation] (Islands__visit_islands___axiom.visit_islands(Islands__visit_islands__map_array.map_array) (Islands__visit_islands__i.i) (([#"islands.adb" 21 0 0] ( [@GP_Id:10] [@vc:annotation] [@GP_Sloc:islands.adb:21:51] [@GP_Reason:VC_OVERFLOW_CHECK] [@GP_Shape:vis_array_assign__call_visit_islands__add] [@comment:      Vis_Array := Visit_Islands(Map_Array,  i, j + 1, Vis_Array);-- recur the right                                                   ^ islands.adb:21:51:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Islands__visit_islands__j.j + (1 : int)))) ))) (Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content)) )) ))) );
   ( [@GP_Sloc:islands.adb:22:7] ([#"islands.adb" 22 0 0] ()) );
   ( [@GP_Sloc:islands.adb:22:56] ([#"islands.adb" 22 0 0] ()) );
   ( [@GP_Sloc:islands.adb:22:20] ([#"islands.adb" 22 0 0] ()) );
   ( [@GP_Sloc:islands.adb:22:17] ([#"islands.adb" 22 0 0] [#"islands.adb" 22 0 0] (Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 22 0 0] ( [@comment:      Vis_Array := Visit_Islands(Map_Array,  i, j - 1, Vis_Array);-- recur the left                    ^ islands.adb:22:20:VC_PRECONDITION] [@GP_Id:13] [@GP_Reason:VC_PRECONDITION] [@GP_Shape:vis_array_assign__call_visit_islands] [@vc:annotation] [@GP_Sloc:islands.adb:22:20] (Islands__visit_islands___axiom.visit_islands(Islands__visit_islands__map_array.map_array) (Islands__visit_islands__i.i) (([#"islands.adb" 22 0 0] ( [@GP_Id:12] [@vc:annotation] [@GP_Reason:VC_OVERFLOW_CHECK] [@GP_Shape:vis_array_assign__call_visit_islands__sub] [@GP_Sloc:islands.adb:22:51] [@comment:      Vis_Array := Visit_Islands(Map_Array,  i, j - 1, Vis_Array);-- recur the left                                                   ^ islands.adb:22:51:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((Islands__visit_islands__j.j - (1 : int)))) ))) (Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content)) )) ))) );
   ( [@GP_Sloc:islands.adb:24:14] ([#"islands.adb" 24 0 0] ()) );
   ( [@GP_Sloc:islands.adb:24:7] ([#"islands.adb" 24 0 0] ( [#"islands.adb" 24 0 0] (islands__visit_islands__result.Array__Int_Int__Bool.map__content <- ( Islands__visit_islands__vis_array.vis_array.Array__Int_Int__Bool.map__content ));
   [#"islands.adb" 24 0 0] raise Return__exc )) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _  = True in (
   ()))
   in () end ;
  islands__visit_islands__result.Array__Int_Int__Bool.map__content )
end

(* Module for declaring an abstract function for the aggregate at islands.adb:29, created in Gnat2Why.Expr.Transform_Aggregate.Generate_Logic_Function *)
module Islands__count_islands__visited_array__aggregate_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val function islands__count_islands__visited_array__aggregate_def 
   (temp___220 : bool) : Array__Int_Int__Bool.map

end

(* Module for defining the value of the aggregate at islands.adb:29, created in Gnat2Why.Expr.Transform_Aggregate.Generate_Logic_Function *)
module Islands__count_islands__visited_array__aggregate_def___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Islands__count_islands__visited_array__aggregate_def as Islands__count_islands__visited_array__aggregate_def
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 axiom def_axiom :
  (forall temp___220   : bool.
   (let temp___219 [@mlw:proxy_symbol] [@introduced]  = (Islands__count_islands__visited_array__aggregate_def.islands__count_islands__visited_array__aggregate_def temp___220) in (
    (forall temp___221   temp___222   : int.
     ((Array__Int_Int__Bool.get temp___219 temp___221 temp___222) = temp___220))))
  )

end

(* Module for defining the constant "map_array" defined at islands.ads:31, created in Gnat2Why.Decls.Translate_Constant *)
module Islands__count_islands__map_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed

 val constant map_array [#"islands.ads" 31 0 0][@model_projected] [@name:Map_Array] [@model_trace:2775] 
   : Array__Int_Int__Islands__int_needed.map

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "visited_array" defined at islands.adb:29, created in Gnat2Why.Decls.Translate_Variable *)
module Islands__count_islands__visited_array
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int_Int__Bool as Array__Int_Int__Bool

 val visited_array [#"islands.adb" 29 0 0][@model_projected] [@name:Visited_Array] [@model_trace:2466]  : Array__Int_Int__Bool.map__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "count" defined at islands.adb:30, created in Gnat2Why.Decls.Translate_Variable *)
module Islands__count_islands__count
 use        "_gnatprove_standard".Main
 use        "int".Int

 val count [#"islands.adb" 30 0 0][@model_projected] [@name:Count] [@model_trace:2482]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "i" defined at islands.adb:35, created in Gnat2Why.Decls.Translate_Variable *)
module Islands__count_islands__L_1__i
 use        "_gnatprove_standard".Main
 use        "int".Int

 val i [#"islands.adb" 35 0 0][@name:i] [@model_projected] [@model_trace:2503]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining a ref holding the value of variable "j" defined at islands.adb:36, created in Gnat2Why.Decls.Translate_Variable *)
module Islands__count_islands__L_2__j
 use        "_gnatprove_standard".Main
 use        "int".Int

 val j [#"islands.adb" 36 0 0][@name:j] [@model_projected] [@model_trace:2516]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for defining the loop exit exception for the loop "L_1" defined at islands.adb:35, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Islands__count_islands__L_1
 use        "_gnatprove_standard".Main
 use        "int".Int

 exception L_1

end

(* Module for defining the loop exit exception for the loop "L_2" defined at islands.adb:36, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Islands__count_islands__L_2
 use        "_gnatprove_standard".Main
 use        "int".Int

 exception L_2

end

(* Module giving an empty axiom for the entity "visited_array" defined at islands.adb:29, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__count_islands__visited_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "count" defined at islands.adb:30, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__count_islands__count___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "i" defined at islands.adb:35, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__count_islands__L_1__i___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "j" defined at islands.adb:36, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__count_islands__L_2__j___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "L_2" defined at islands.adb:36, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__count_islands__L_2___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "L_1" defined at islands.adb:35, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__count_islands__L_1___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving an empty axiom for the entity "map_array" defined at islands.ads:31, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Islands__count_islands__map_array___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for checking contracts and absence of run-time errors in subprogram "count_islands" defined at islands.ads:31, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Islands__count_islands__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Boolean as Boolean
 use        Standard__integer as Standard__integer
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Islands__water as Islands__water
 use        Islands__land as Islands__land
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Islands__visit_islands___axiom as Islands__visit_islands___axiom
 use        Islands__count_islands__map_array as Islands__count_islands__map_array
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Islands__count_islands__visited_array as Islands__count_islands__visited_array
 use        Islands__count_islands__count as Islands__count_islands__count
 use        Islands__count_islands__L_1__i as Islands__count_islands__L_1__i
 use        Islands__count_islands__L_2__j as Islands__count_islands__L_2__j
 use        Islands__int_needed as Islands__int_needed
 use        Islands__int_needed___axiom as Islands__int_needed___axiom
 use        Islands__int_needed__rep as Islands__int_needed__rep
 use        Array__Int_Int__Islands__int_needed as Array__Int_Int__Islands__int_needed
 use        Islands__map___axiom as Islands__map___axiom
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Islands__visited___axiom as Islands__visited___axiom
 use        Islands__count_islands__L_1 as Islands__count_islands__L_1
 use        Islands__count_islands__L_2 as Islands__count_islands__L_2
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Islands__count_islands__visited_array__aggregate_def as Islands__count_islands__visited_array__aggregate_def
 use        Array__Int_Int__Bool as Array__Int_Int__Bool
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Islands__count_islands__visited_array___axiom as Islands__count_islands__visited_array___axiom
 use        Islands__count_islands__visited_array__aggregate_def___axiom as Islands__count_islands__visited_array__aggregate_def___axiom
 use        Islands__count_islands__count___axiom as Islands__count_islands__count___axiom
 use        Islands__count_islands__L_1__i___axiom as Islands__count_islands__L_1__i___axiom
 use        Islands__count_islands__L_2__j___axiom as Islands__count_islands__L_2__j___axiom
 use        Islands__count_islands__L_2___axiom as Islands__count_islands__L_2___axiom
 use        Islands__count_islands__L_1___axiom as Islands__count_islands__L_1___axiom
 use        Islands__int_needed___axiom as Islands__int_needed___axiom
 use        Islands__water___axiom as Islands__water___axiom
 use        Islands__land___axiom as Islands__land___axiom
 use        Islands__map___axiom as Islands__map___axiom
 use        Islands__visited___axiom as Islands__visited___axiom
 use        Islands__visit_islands___axiom as Islands__visit_islands___axiom
 use        Islands__count_islands__map_array___axiom as Islands__count_islands__map_array___axiom

 val islands__count_islands__result [@model_projected] [@name:Count_Islands] [@model_trace:2768@result]  : int__ref 
 
 let def [#"islands.ads" 31 0 0][@GP_Subp:islands.ads:31] 
   (__void_param : unit)
  requires { [#"islands.ads" 31 0 0] true }
  ensures { [#"islands.ads" 31 0 0] ([#"islands.ads" 33 0 0] ( [@GP_Reason:VC_POSTCONDITION] [@GP_Id:18] [@GP_Sloc:islands.ads:33:14] [@GP_Shape:pragargs__cmp] [@comment:     Post => (Count_Islands'Result < (N * M));              ^ islands.ads:33:14:VC_POSTCONDITION] [@model_vc_post] ( [@GP_Pretty_Ada:2889] [@GP_Sloc:islands.ads:33:14] (islands__count_islands__result.int__content < (20 : int)) ) )) }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram islands.ads:31 *)
  ;
   assume {  (Islands__int_needed___axiom.dynamic_invariant Islands__water.water.int__content True False True True) };
   assume {  (Islands__int_needed___axiom.dynamic_invariant Islands__land.land.int__content True False True True) };
   assume {  (Islands__map___axiom.dynamic_invariant Islands__count_islands__map_array.map_array True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram islands.ads:31 *)
  ;
  () (* Check for RTE in the Pre of the subprogram islands.ads:31 *)
  ;
   begin ensures {true} let _ = (let _  = (Boolean.of_int((1 : int))) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram islands.ads:31 *)
  ;
   assume {  ( [@GP_Pretty_Ada:2876] true ) };
   try
   ( ();
   ([#"islands.adb" 29 0 0] ( [#"islands.adb" 29 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( (Islands__count_islands__visited_array__aggregate_def.islands__count_islands__visited_array__aggregate_def((Boolean.of_int((0 : int))))) ));
   [#"islands.adb" 29 0 0] assume { [#"islands.adb" 29 0 0] (Islands__visited___axiom.dynamic_invariant Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content True False True True) } ));
   ([#"islands.adb" 30 0 0] ( [#"islands.adb" 30 0 0] (Islands__count_islands__count.count.int__content <- ( (0 : int) ));
   [#"islands.adb" 30 0 0] assume { [#"islands.adb" 30 0 0] (Standard__integer___axiom.dynamic_invariant Islands__count_islands__count.count.int__content True False True True) } ));
   ([#"islands.adb" 36 0 0] ());
   ([#"islands.adb" 35 0 0] ());
   ();
   ( [@GP_Sloc:islands.adb:32:7] ([#"islands.adb" 32 0 0] (if (( ([#"islands.adb" 32 0 0] [#"islands.adb" 32 0 0] (([@branch_id=2493] Main.spark__branch).bool__content <- ( (Boolean.of_int((0 : int))) )));
   ( [@branch_id=2493] Main.spark__branch ).bool__content )) then (
    ( ();
    ( [@GP_Sloc:islands.adb:33:10] ([#"islands.adb" 33 0 0] ( [#"islands.adb" 33 0 0] (islands__count_islands__result.int__content <- ( (0 : int) ));
    [#"islands.adb" 33 0 0] raise Return__exc )) ) )) else (
    ()))) );
   ( [@GP_Sloc:islands.adb:35:24] ([#"islands.adb" 35 0 0] (let temp___223 [@mlw:proxy_symbol] [@introduced]  = (1 : int) in (
   (let temp___224 [@mlw:proxy_symbol] [@introduced]  = (4 : int) in (
    ( () (* Translation of an unrolled Ada loop from islands.adb:35 *)
    ;
    [#"islands.adb" 35 0 0] try
     ( [#"islands.adb" 35 0 0] begin ensures {true} let _ = (let _  = Islands__count_islands__count.count.int__content in (
      ()))
      in () end ;
     (let temp___loop_entry_230  = [#"islands.adb" 35 0 0] (val _f : int
     ensures {[#"islands.adb" 35 0 0] (result = Islands__count_islands__count.count.int__content)} 
     in _f) in (
      ( [#"islands.adb" 35 0 0] begin ensures {true} let _ = (let _  = Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content in (
       ()))
       in () end ;
      (let temp___loop_entry_229  = [#"islands.adb" 35 0 0] (val _f : Array__Int_Int__Bool.map
      ensures {[#"islands.adb" 35 0 0] (result = Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)} 
      in _f) in (
       ( () (* Unrolling of the loop statements of loop islands.adb:35 *)
       ;
       [#"islands.adb" 35 0 0] (Islands__count_islands__L_1__i.i.int__content <- ( (1 : int) ));
       ();
       ( [@GP_Sloc:islands.adb:36:27] ([#"islands.adb" 36 0 0] (let temp___225 [@mlw:proxy_symbol] [@introduced]  = (1 : int) in (
       (let temp___226 [@mlw:proxy_symbol] [@introduced]  = (5 : int) in (
        ( () (* Translation of an unrolled Ada loop from islands.adb:36 *)
        ;
        [#"islands.adb" 36 0 0] try
         ( [#"islands.adb" 36 0 0] begin ensures {true} let _ = (let _  = Islands__count_islands__count.count.int__content in (
          ()))
          in () end ;
         (let temp___loop_entry_228  = [#"islands.adb" 36 0 0] (val _f : int
         ensures {[#"islands.adb" 36 0 0] (result = Islands__count_islands__count.count.int__content)} 
         in _f) in (
          ( [#"islands.adb" 36 0 0] begin ensures {true} let _ = (let _  = Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content in (
           ()))
           in () end ;
          (let temp___loop_entry_227  = [#"islands.adb" 36 0 0] (val _f : Array__Int_Int__Bool.map
          ensures {[#"islands.adb" 36 0 0] (result = Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)} 
          in _f) in (
           ( () (* Unrolling of the loop statements of loop islands.adb:36 *)
           ;
           [#"islands.adb" 36 0 0] (Islands__count_islands__L_2__j.j.int__content <- ( (1 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (2 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (3 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (4 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (5 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) ) )))
           )))
          )
        with
         Islands__count_islands__L_2.L_2 -> ()
        end )))
       ))
       ) );
        (Islands__count_islands__L_1__i.i.int__content <- ( (2 : int) ));
       ();
       ( [@GP_Sloc:islands.adb:36:27] ([#"islands.adb" 36 0 0] (let temp___225 [@mlw:proxy_symbol] [@introduced]  = (1 : int) in (
       (let temp___226 [@mlw:proxy_symbol] [@introduced]  = (5 : int) in (
        ( () (* Translation of an unrolled Ada loop from islands.adb:36 *)
        ;
        [#"islands.adb" 36 0 0] try
         ( [#"islands.adb" 36 0 0] begin ensures {true} let _ = (let _  = Islands__count_islands__count.count.int__content in (
          ()))
          in () end ;
         (let temp___loop_entry_228  = [#"islands.adb" 36 0 0] (val _f : int
         ensures {[#"islands.adb" 36 0 0] (result = Islands__count_islands__count.count.int__content)} 
         in _f) in (
          ( [#"islands.adb" 36 0 0] begin ensures {true} let _ = (let _  = Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content in (
           ()))
           in () end ;
          (let temp___loop_entry_227  = [#"islands.adb" 36 0 0] (val _f : Array__Int_Int__Bool.map
          ensures {[#"islands.adb" 36 0 0] (result = Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)} 
          in _f) in (
           ( () (* Unrolling of the loop statements of loop islands.adb:36 *)
           ;
           [#"islands.adb" 36 0 0] (Islands__count_islands__L_2__j.j.int__content <- ( (1 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (2 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (3 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (4 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (5 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) ) )))
           )))
          )
        with
         Islands__count_islands__L_2.L_2 -> ()
        end )))
       ))
       ) );
        (Islands__count_islands__L_1__i.i.int__content <- ( (3 : int) ));
       ();
       ( [@GP_Sloc:islands.adb:36:27] ([#"islands.adb" 36 0 0] (let temp___225 [@mlw:proxy_symbol] [@introduced]  = (1 : int) in (
       (let temp___226 [@mlw:proxy_symbol] [@introduced]  = (5 : int) in (
        ( () (* Translation of an unrolled Ada loop from islands.adb:36 *)
        ;
        [#"islands.adb" 36 0 0] try
         ( [#"islands.adb" 36 0 0] begin ensures {true} let _ = (let _  = Islands__count_islands__count.count.int__content in (
          ()))
          in () end ;
         (let temp___loop_entry_228  = [#"islands.adb" 36 0 0] (val _f : int
         ensures {[#"islands.adb" 36 0 0] (result = Islands__count_islands__count.count.int__content)} 
         in _f) in (
          ( [#"islands.adb" 36 0 0] begin ensures {true} let _ = (let _  = Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content in (
           ()))
           in () end ;
          (let temp___loop_entry_227  = [#"islands.adb" 36 0 0] (val _f : Array__Int_Int__Bool.map
          ensures {[#"islands.adb" 36 0 0] (result = Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)} 
          in _f) in (
           ( () (* Unrolling of the loop statements of loop islands.adb:36 *)
           ;
           [#"islands.adb" 36 0 0] (Islands__count_islands__L_2__j.j.int__content <- ( (1 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (2 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (3 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (4 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (5 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) ) )))
           )))
          )
        with
         Islands__count_islands__L_2.L_2 -> ()
        end )))
       ))
       ) );
        (Islands__count_islands__L_1__i.i.int__content <- ( (4 : int) ));
       ();
       ( [@GP_Sloc:islands.adb:36:27] ([#"islands.adb" 36 0 0] (let temp___225 [@mlw:proxy_symbol] [@introduced]  = (1 : int) in (
       (let temp___226 [@mlw:proxy_symbol] [@introduced]  = (5 : int) in (
        ( () (* Translation of an unrolled Ada loop from islands.adb:36 *)
        ;
        [#"islands.adb" 36 0 0] try
         ( [#"islands.adb" 36 0 0] begin ensures {true} let _ = (let _  = Islands__count_islands__count.count.int__content in (
          ()))
          in () end ;
         (let temp___loop_entry_228  = [#"islands.adb" 36 0 0] (val _f : int
         ensures {[#"islands.adb" 36 0 0] (result = Islands__count_islands__count.count.int__content)} 
         in _f) in (
          ( [#"islands.adb" 36 0 0] begin ensures {true} let _ = (let _  = Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content in (
           ()))
           in () end ;
          (let temp___loop_entry_227  = [#"islands.adb" 36 0 0] (val _f : Array__Int_Int__Bool.map
          ensures {[#"islands.adb" 36 0 0] (result = Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)} 
          in _f) in (
           ( () (* Unrolling of the loop statements of loop islands.adb:36 *)
           ;
           [#"islands.adb" 36 0 0] (Islands__count_islands__L_2__j.j.int__content <- ( (1 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (2 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (3 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (4 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) );
            (Islands__count_islands__L_2__j.j.int__content <- ( (5 : int) ));
           ();
           ( [@GP_Sloc:islands.adb:37:13] ([#"islands.adb" 37 0 0] (if (( ([#"islands.adb" 37 0 0] [#"islands.adb" 37 0 0] (([@branch_id=2527] Main.spark__branch).bool__content <- ( ( ((Islands__int_needed__rep.to_rep((Array__Int_Int__Islands__int_needed.get(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)))) = (1 : int)) && not ( (Array__Int_Int__Bool.get(Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content)) ) ) )));
           ( [@branch_id=2527] Main.spark__branch ).bool__content )) then (
            ( ();
            ( [@GP_Sloc:islands.adb:39:16] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:64] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:33] ([#"islands.adb" 39 0 0] ()) );
            ( [@GP_Sloc:islands.adb:39:30] ([#"islands.adb" 39 0 0] [#"islands.adb" 39 0 0] (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content <- ( ([#"islands.adb" 39 0 0] ( [@GP_Reason:VC_PRECONDITION] [@GP_Id:16] [@GP_Sloc:islands.adb:39:33] [@vc:annotation] [@comment:               Visited_Array := Visit_Islands(Map_Array, i, j, Visited_Array);                                 ^ islands.adb:39:33:VC_PRECONDITION] [@GP_Shape:L_1_while__L_2_while__if__visited_array_assign__call_visit_islands] (Islands__visit_islands___axiom.visit_islands(Islands__count_islands__map_array.map_array) (Islands__count_islands__L_1__i.i.int__content) (Islands__count_islands__L_2__j.j.int__content) (Islands__count_islands__visited_array.visited_array.Array__Int_Int__Bool.map__content)) )) ))) );
            ( [@GP_Sloc:islands.adb:40:16] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:25] ([#"islands.adb" 40 0 0] ()) );
            ( [@GP_Sloc:islands.adb:40:22] ([#"islands.adb" 40 0 0] [#"islands.adb" 40 0 0] (Islands__count_islands__count.count.int__content <- ( ([#"islands.adb" 40 0 0] ( [@GP_Id:17] [@vc:annotation] [@GP_Shape:L_1_while__L_2_while__if__count_assign__add] [@GP_Reason:VC_OVERFLOW_CHECK] [@comment:               Count := Count + 1;                               ^ islands.adb:40:31:VC_OVERFLOW_CHECK] [@GP_Sloc:islands.adb:40:31] (Standard__integer.range_check_((Islands__count_islands__count.count.int__content + (1 : int)))) )) ))) ) )) else (
            ()))) ) )))
           )))
          )
        with
         Islands__count_islands__L_2.L_2 -> ()
        end )))
       ))
       ) ) )))
       )))
      )
    with
     Islands__count_islands__L_1.L_1 -> ()
    end )))
   ))
   ) );
   ( [@GP_Sloc:islands.adb:44:14] ([#"islands.adb" 44 0 0] ()) );
   ( [@GP_Sloc:islands.adb:44:7] ([#"islands.adb" 44 0 0] ( [#"islands.adb" 44 0 0] (islands__count_islands__result.int__content <- ( Islands__count_islands__count.count.int__content ));
   [#"islands.adb" 44 0 0] raise Return__exc )) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _  = (islands__count_islands__result.int__content < (20 : int)) in (
   ()))
   in () end ;
  islands__count_islands__result.int__content )
end
